{
    "filter_even_numbers": {
        "code": "\n\ndef filter_even_numbers(input_list):\n    even_numbers = []\n    for number in input_list:\n        if ((number % 2) == 0):\n            even_numbers.append(number)\n    return even_numbers\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list containing only the even numbers from the original list.",
        "description": "\n[description for function: filter_even_numbers]\nThis function takes a list of numbers as input and iterates through each number to check if it is even. If a number is found to be even (i.e., divisible by 2 with no remainder), it is added to a new list. After processing all the numbers, the function returns the list containing only the even numbers. The output will be an array that excludes any odd numbers from the original input. This allows users to easily filter out even values from a mixed list of integers. The function effectively provides a simple way to identify and collect even numbers.\n\n[end of description]\n"
    },
    "count_string_occurrences": {
        "code": "\n\ndef count_string_occurrences(string_list):\n    count_dict = {}\n    for string in string_list:\n        if (string in count_dict):\n            count_dict[string] += 1\n        else:\n            count_dict[string] = 1\n    return count_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a dictionary where the keys are the strings and the values are the number of times each string appears in the list.",
        "description": "\n[description for function: count_string_occurrences]\nThis function takes a list of strings as input and counts the occurrences of each unique string in that list. It initializes an empty dictionary to store the counts. As it iterates through the list, it checks if each string is already a key in the dictionary; if so, it increments the count, otherwise, it adds the string with a count of one. Finally, it returns the dictionary containing the strings and their corresponding counts. This allows for easy retrieval of how many times each string appears in the input list. The function effectively summarizes the frequency of each string in the provided list.\n\n[end of description]\n"
    },
    "group_strings_by_length": {
        "code": "\n\ndef group_strings_by_length(strings):\n    length_dict = {}\n    for string in strings:\n        length = len(string)\n        if (length in length_dict):\n            length_dict[length].append(string)\n        else:\n            length_dict[length] = [string]\n    return length_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a dictionary where the keys are the lengths of the strings and the values are lists of strings of that length.",
        "description": "\n[description for function: group_strings_by_length]\nThis function takes a list of strings and organizes them into a dictionary where the keys are the lengths of the strings and the values are lists of strings that share the same length. It iterates through each string in the input list, calculates its length, and then adds it to the corresponding list in the dictionary. If a length key already exists, the string is appended to the existing list; otherwise, a new list is created for that length. Finally, the function returns the constructed dictionary, providing a clear grouping of strings by their lengths. This allows for easy access to all strings of a specific length. The output is a structured representation of the input strings based on their lengths.\n\n[end of description]\n"
    },
    "first_non_repeating_char": {
        "code": "\n\ndef first_non_repeating_char(s):\n    char_count = {}\n    for char in s:\n        char_count[char] = (char_count.get(char, 0) + 1)\n    for char in s:\n        if (char_count[char] == 1):\n            return char\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the first non-repeating character in it. If all characters repeat, return None.",
        "description": "\n[description for function: first_non_repeating_char]\nThis function takes a string as input and counts the occurrences of each character in it. It uses a dictionary to store the count of each character. After counting, it iterates through the string again to find the first character that appears only once. If such a character is found, it is returned as the result. If no non-repeating character exists, the function returns None. This effectively identifies the first unique character in the given string.\n\n[end of description]\n"
    },
    "find_pairs_with_sum": {
        "code": "from collections import Counter\n\ndef find_pairs_with_sum(nums, target):\n    from collections import Counter\n    num_count = Counter(nums)\n    unique_pairs = set()\n    for num in nums:\n        complement = (target - num)\n        if (complement in num_count):\n            if ((num == complement) and (num_count[num] < 2)):\n                continue\n            pair = (min(num, complement), max(num, complement))\n            unique_pairs.add(pair)\n    return sorted(list(unique_pairs))\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of all unique pairs (as tuples) that sum up to a given target integer. The pairs should be sorted in ascending order, and each pair should be sorted as well.",
        "description": "\n[description for function: find_pairs_with_sum]\nThis function takes a list of integers and a target sum as input, and it identifies all unique pairs of numbers from the list that add up to the target sum. It utilizes a counter to keep track of the occurrences of each number in the list. As it iterates through the numbers, it calculates the complement needed to reach the target sum and checks if it exists in the counter. If the number and its complement are the same, it ensures there are at least two occurrences of that number. The pairs are stored in a set to maintain uniqueness and are returned as a sorted list.\n\n[end of description]\n"
    },
    "longest_unique_substring": {
        "code": "\n\ndef longest_unique_substring(s):\n    char_set = set()\n    max_length = 0\n    start = 0\n    longest_substr = ''\n    for end in range(len(s)):\n        while (s[end] in char_set):\n            char_set.remove(s[start])\n            start += 1\n        char_set.add(s[end])\n        if (((end - start) + 1) > max_length):\n            max_length = ((end - start) + 1)\n            longest_substr = s[start:(end + 1)]\n    return longest_substr\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the longest substring without repeating characters.",
        "description": "\n[description for function: longest_unique_substring]\nThis function takes a string as input and finds the longest substring that contains all unique characters. It uses a sliding window approach, maintaining a set of characters currently in the substring and adjusting the start index as needed to ensure uniqueness. As it iterates through the string, it updates the maximum length and the corresponding substring whenever a longer unique substring is found. The function ultimately returns the longest substring with all unique characters. It efficiently handles the input by ensuring that each character is processed only once. The result is a single substring that meets the criteria.\n\n[end of description]\n"
    },
    "find_common_elements": {
        "code": "\n\ndef find_common_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    common_set = (set1 & set2)\n    result = sorted(common_set)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a list of their common elements. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: find_common_elements]\nThis function takes two lists as input and converts them into sets to eliminate duplicates. It then finds the intersection of these two sets, which contains the common elements. The resulting set of common elements is sorted in ascending order. Finally, the function returns this sorted list of common elements.\n\n[end of description]\n"
    },
    "bubble_sort": {
        "code": "\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range((n - 1)):\n        for j in range(((n - 1) - i)):\n            if (arr[j] > arr[(j + 1)]):\n                (arr[j], arr[(j + 1)]) = (arr[(j + 1)], arr[j])\n    return arr\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and sorts it in ascending order using the bubble sort algorithm. The function should return the sorted list.",
        "description": "\n[description for function: bubble_sort]\nThis function sorts a given list of numbers in ascending order using the bubble sort algorithm. It iterates through the list multiple times, comparing adjacent elements and swapping them if they are in the wrong order. The process is repeated until the entire list is sorted. The outer loop controls the number of passes, while the inner loop performs the comparisons and swaps. The function modifies the original list in place and returns the sorted list. Overall, it efficiently organizes the elements by repeatedly \"bubbling\" the largest unsorted element to its correct position.\n\n[end of description]\n"
    },
    "reverse_list": {
        "code": "\n\ndef reverse_list(input_list):\n    return input_list[::(- 1)]\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the elements in reverse order.",
        "description": "\n[description for function: reverse_list]\nThis function takes a list as input and returns a new list that contains the elements of the input list in reverse order. It utilizes Python's slicing feature to achieve this by specifying a step of -1. The result is a reversed version of the original list without modifying the input list itself. This approach is concise and efficient for reversing lists. The function can handle lists of any data type, including mixed types. Overall, it provides a simple way to reverse the order of elements in a list.\n\n[end of description]\n"
    },
    "find_gcd_of_list": {
        "code": "\n\ndef gcd(a, b):\n    while (b != 0):\n        (a, b) = (b, (a % b))\n    return a\n\n\n\n\ndef find_gcd_of_list(numbers):\n    if (not numbers):\n        return None\n    current_gcd = numbers[0]\n    for num in numbers[1:]:\n        current_gcd = gcd(current_gcd, num)\n    return current_gcd\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the greatest common divisor (GCD) of the numbers in the list. Use the Euclidean algorithm to find the GCD.",
        "description": "\n[description for function: find_gcd_of_list]\nThis function calculates the greatest common divisor (GCD) of a list of numbers by iteratively applying the GCD calculation to each element in the list, starting with the first number as the initial GCD. If the input list is empty, it returns None. It initializes the current GCD with the first number and then updates it by finding the GCD with each subsequent number in the list. Finally, it returns the computed GCD for the entire list.\n\n[end of description]\n"
    },
    "remove_vowels": {
        "code": "\n\ndef remove_vowels(input_string):\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in input_string:\n        if (char not in vowels):\n            result.append(char)\n    return ''.join(result)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns a new string with all the vowels removed. The function should be case-insensitive, meaning it should remove both uppercase and lowercase vowels.",
        "description": "\n[description for function: remove_vowels]\nThis function takes a string as input and removes all vowels from it, including both uppercase and lowercase letters. It initializes an empty list to store the characters that are not vowels. As it iterates through each character in the input string, it checks if the character is not a vowel and, if so, appends it to the result list. Finally, it joins the characters in the result list into a single string and returns that string without vowels.\n\n[end of description]\n"
    },
    "common_elements": {
        "code": "\n\ndef common_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    common_set = (set1 & set2)\n    return list(common_set)\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a list of integers that are present in both lists, without duplicates. Use set operations to achieve this.",
        "description": "\n[description for function: common_elements]\nThis function takes two lists as input and converts them into sets to eliminate any duplicate values. It then computes the intersection of these two sets to identify the common elements present in both lists. Finally, it returns the common elements as a new list. The use of sets ensures that the operation is efficient and that the result contains unique values. The output will only include elements that appear in both input lists. Overall, it provides a straightforward way to find shared items between two collections.\n\n[end of description]\n"
    },
    "simulate_stack_operations": {
        "code": "\n\ndef simulate_stack_operations(operations):\n    stack = []\n    results = []\n    for operation in operations:\n        if operation.startswith('push'):\n            (_, value) = operation.split()\n            stack.append(int(value))\n        elif (operation == 'pop'):\n            if stack:\n                results.append(stack.pop())\n            else:\n                results.append(None)\n        elif (operation == 'peek'):\n            if stack:\n                results.append(stack[(- 1)])\n            else:\n                results.append(None)\n    return results\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of operations (as strings) and simulates a stack using a list. The operations can be 'push X' to push an integer X onto the stack, 'pop' to remove the top element, and 'peek' to return the top element without removing it. The function should return a list of results from the 'pop' and 'peek' operations.",
        "description": "\n[description for function: simulate_stack_operations]\nThis function simulates a series of stack operations based on a list of commands. It initializes an empty stack and processes each operation, which can be to push a value onto the stack, pop the top value off the stack, or peek at the top value without removing it. When pushing, it converts the value to an integer before adding it to the stack. If a pop or peek operation is attempted on an empty stack, it appends `None` to the results list. The function returns a list of results corresponding to the pop and peek operations. Overall, it effectively manages stack behavior and provides feedback on the operations performed.\n\n[end of description]\n"
    },
    "symmetric_difference": {
        "code": "\n\ndef symmetric_difference(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    result_set = (set1 ^ set2)\n    result_list = sorted(result_set)\n    return result_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a list of integers that are present in either of the lists but not in both. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: symmetric_difference]\nThis function calculates the symmetric difference between two lists by converting them into sets, which allows for the identification of elements that are unique to each set. It uses the symmetric difference operator to find elements that are in either of the sets but not in both. The resulting set is then sorted to produce a list of the unique elements in ascending order. Finally, the function returns this sorted list. This provides a clear and efficient way to determine the unique elements from two input lists.\n\n[end of description]\n"
    },
    "count_integers": {
        "code": "\n\ndef count_integers(int_list):\n    count_dict = {}\n    for num in int_list:\n        if (num in count_dict):\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a dictionary where the keys are the integers and the values are the number of times each integer appears in the list. This will help practice using dictionaries for counting occurrences.",
        "description": "\n[description for function: count_integers]\nThis function takes a list of integers as input and counts the occurrences of each integer in the list. It initializes an empty dictionary to store the counts. As it iterates through the list, it updates the count for each integer, either by incrementing the existing count or initializing it to one if the integer is encountered for the first time. Finally, it returns the dictionary containing the integers and their corresponding counts. This allows for a quick overview of how many times each integer appears in the input list. The function effectively provides a frequency distribution of the integers.\n\n[end of description]\n"
    },
    "find_primes_less_than": {
        "code": "\n\ndef find_primes_less_than(n):\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, (int((num ** 0.5)) + 1)):\n            if ((num % i) == 0):\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns a list of all prime numbers less than n. This will help you practice loops, conditionals, and understanding of prime numbers.",
        "description": "\n[description for function: find_primes_less_than]\nThis function generates a list of all prime numbers that are less than a specified integer, n. It iterates through each number starting from 2 up to n-1 and checks if the number is prime by testing divisibility with all integers up to its square root. If a number is found to be prime, it is added to the list of primes. The function ultimately returns the complete list of prime numbers found. It efficiently determines primality by reducing the number of divisibility checks needed. The result is a collection of prime numbers that can be used for various mathematical applications.\n\n[end of description]\n"
    },
    "is_pattern_in_string": {
        "code": "\n\ndef is_pattern_in_string(main_string, pattern):\n    return (pattern in main_string)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and a pattern (both strings) and returns True if the pattern is found in the string, and False otherwise. The function should perform a simple substring search.",
        "description": "\n[description for function: is_pattern_in_string]\nThis function checks if a specified pattern exists within a given main string. It takes two arguments: the main string and the pattern to search for. The function utilizes the 'in' operator to determine if the pattern is a substring of the main string. It returns a boolean value, either True or False, based on the presence of the pattern. This allows for quick and efficient substring searching. Overall, it provides a straightforward way to verify the existence of a sequence of characters within another string.\n\n[end of description]\n"
    },
    "recursive_factorial": {
        "code": "\n\ndef recursive_factorial(n):\n    if (n == 0):\n        return 1\n    else:\n        return (n * recursive_factorial((n - 1)))\n",
        "dependencies": [],
        "task": "Write a Python function that calculates the factorial of a given non-negative integer using recursion. The function should return the factorial value.",
        "description": "\n[description for function: recursive_factorial]\nThis function calculates the factorial of a non-negative integer using recursion. If the input is zero, it returns 1, as the factorial of zero is defined to be 1. For any positive integer, it multiplies the integer by the factorial of the integer minus one, effectively reducing the problem size with each recursive call. The process continues until it reaches the base case of zero. The final result is the product of all integers from the input down to one. This approach elegantly demonstrates the concept of recursion in programming.\n\n[end of description]\n"
    },
    "find_max_index": {
        "code": "\n\ndef find_max_index(nums):\n    if (not nums):\n        return (- 1)\n    max_value = nums[0]\n    max_index = 0\n    for index in range(len(nums)):\n        if (nums[index] > max_value):\n            max_value = nums[index]\n            max_index = index\n    return max_index\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the index of the first occurrence of the maximum value in the list. If the list is empty, return -1.",
        "description": "\n[description for function: find_max_index]\nThis function takes a list of numbers as input and returns the index of the maximum value in the list. If the list is empty, it returns -1. It initializes the maximum value and its index with the first element of the list. It then iterates through the list, updating the maximum value and its index whenever a larger value is found. Finally, it returns the index of the maximum value. The function effectively identifies the position of the highest number in the provided list.\n\n[end of description]\n"
    },
    "find_k_largest": {
        "code": "import heapq\n\ndef find_k_largest(nums, k):\n    if (k > len(nums)):\n        return sorted(nums, reverse=True)\n    min_heap = []\n    for num in nums:\n        if (len(min_heap) < k):\n            heapq.heappush(min_heap, num)\n        elif (num > min_heap[0]):\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, num)\n    return sorted(min_heap, reverse=True)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of the k largest elements in descending order. Use a min-heap to efficiently find the k largest elements.",
        "description": "\n[description for function: find_k_largest]\nThis function identifies the k largest elements from a given list of numbers. It first checks if k exceeds the length of the list, in which case it returns the entire list sorted in descending order. A min-heap is utilized to efficiently track the largest k elements as the function iterates through the list. If the heap contains fewer than k elements, it adds the current number; otherwise, it replaces the smallest element in the heap if the current number is larger. Finally, it returns the k largest elements sorted in descending order. This approach ensures optimal performance even with large datasets.\n\n[end of description]\n"
    },
    "find_duplicates": {
        "code": "from collections import Counter\n\ndef find_duplicates(int_list):\n    counts = Counter(int_list)\n    duplicates = [num for (num, count) in counts.items() if (count > 1)]\n    duplicates.sort()\n    return duplicates\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of all integers that appear more than once in the list. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: find_duplicates]\nThis function takes a list of integers as input and identifies the numbers that appear more than once. It utilizes the Counter class from the collections module to count the occurrences of each integer in the list. The function then creates a list of those integers that have a count greater than one, indicating they are duplicates. After identifying the duplicates, it sorts them in ascending order. Finally, the sorted list of duplicate integers is returned.\n\n[end of description]\n"
    },
    "quicksort": {
        "code": "\n\ndef quicksort(arr):\n    if (len(arr) <= 1):\n        return arr\n    else:\n        pivot = arr[(len(arr) // 2)]\n        left = [x for x in arr if (x < pivot)]\n        middle = [x for x in arr if (x == pivot)]\n        right = [x for x in arr if (x > pivot)]\n        return ((quicksort(left) + middle) + quicksort(right))\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the list sorted in ascending order using the quicksort algorithm. This will help you practice implementing a classic sorting algorithm and understanding its recursive nature.",
        "description": "\n[description for function: quicksort]\nThis function implements the quicksort algorithm to sort an array. It first checks if the array has one or no elements, in which case it returns the array as is. If the array has more than one element, it selects a pivot element and partitions the array into three sub-arrays: those less than the pivot, those equal to the pivot, and those greater than the pivot. It then recursively sorts the left and right sub-arrays. Finally, it combines the sorted left sub-array, the middle sub-array, and the sorted right sub-array to produce the final sorted array. The function effectively sorts the input array in ascending order.\n\n[end of description]\n"
    },
    "is_palindrome": {
        "code": "import re\n\ndef is_palindrome(s):\n    cleaned = re.sub('[^a-zA-Z0-9]', '', s).lower()\n    return (cleaned == cleaned[::(- 1)])\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns True if the string is a palindrome (reads the same forwards and backwards), ignoring spaces, punctuation, and capitalization. Otherwise, return False.",
        "description": "\n[description for function: is_palindrome]\nThis function checks if a given string is a palindrome, which means it reads the same forwards and backwards. It first removes any non-alphanumeric characters and converts the string to lowercase for uniformity. After cleaning the string, it compares the cleaned version to its reverse. If both are identical, it returns True, indicating that the string is a palindrome; otherwise, it returns False. The function effectively handles various input formats by focusing solely on the alphanumeric content. Overall, it provides a straightforward way to determine palindrome status for any input string.\n\n[end of description]\n"
    },
    "unique_elements": {
        "code": "from collections import Counter\n\ndef unique_elements(input_list):\n    counts = Counter(input_list)\n    unique_integers = [num for (num, count) in counts.items() if (count == 1)]\n    unique_integers.sort()\n    return unique_integers\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of integers that appear only once in the original list. The result should be sorted in ascending order.",
        "description": "\n[description for function: unique_elements]\nThis function takes a list as input and counts the occurrences of each element using the Counter class. It then creates a new list containing only the elements that appear exactly once in the input list. After filtering, the unique elements are sorted in ascending order. Finally, the function returns the sorted list of unique integers.\n\n[end of description]\n"
    },
    "find_substrings": {
        "code": "\n\ndef find_substrings(input_string, word_list):\n    result = []\n    for word in word_list:\n        if (word in input_string):\n            result.append(word)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and a list of words, and returns a list of words from the list that are substrings of the given string. This will help practice string manipulation and searching techniques.",
        "description": "\n[description for function: find_substrings]\nThis function takes an input string and a list of words, then checks each word to see if it is present in the input string. If a word is found within the input string, it is added to a result list. After checking all the words, the function returns the list of found words. The function effectively filters the word list based on their presence in the input string. It is useful for identifying specific substrings from a larger text. The output is a list containing all the words that were found.\n\n[end of description]\n"
    },
    "find_duplicates_v2": {
        "code": "from collections import Counter\n\ndef find_duplicates_v2(input_list):\n    counts = Counter(input_list)\n    duplicates = {num for (num, count) in counts.items() if (count > 1)}\n    return sorted(duplicates)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of integers that appear more than once in the list. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: find_duplicates]\nThis function takes a list as input and identifies the elements that appear more than once. It utilizes the Counter class from the collections module to count the occurrences of each element in the list. The function then creates a set of elements that have a count greater than one, indicating they are duplicates. Finally, it returns a sorted list of these duplicate elements. The output is a list containing only the unique duplicates, arranged in ascending order. This allows for easy identification of repeated items in the original list.\n\n[end of description]\n"
    },
    "find_duplicates_v3": {
        "code": "\n\ndef find_duplicates_v3(input_list):\n    seen = set()\n    duplicates = set()\n    for number in input_list:\n        if (number in seen):\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    return sorted(duplicates)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of integers that are duplicates in the original list. The result should not contain duplicates and should be sorted in ascending order. Use a set to efficiently find duplicates.",
        "description": "\n[description for function: find_duplicates]\nThis function takes a list of numbers as input and identifies any duplicate values within that list. It utilizes a set to keep track of numbers that have already been encountered and another set to store duplicates. As it iterates through the input list, it checks if each number has been seen before; if so, it adds it to the duplicates set. Finally, the function returns a sorted list of the duplicate numbers found. The use of sets ensures that each duplicate is only recorded once, regardless of how many times it appears in the input list. Overall, it efficiently identifies and returns the duplicates in a sorted order.\n\n[end of description]\n"
    },
    "is_valid_parentheses": {
        "code": "\n\ndef is_valid_parentheses(s: str) -> bool:\n    stack = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if (char in bracket_map.values()):\n            stack.append(char)\n        elif (char in bracket_map.keys()):\n            if ((not stack) or (stack.pop() != bracket_map[char])):\n                return False\n    return (not stack)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string containing only the characters '(', ')', '{', '}', '[' and ']', and returns True if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. The function should return False otherwise.",
        "description": "\n[description for function: is_valid_parentheses]\nThis function checks if a given string of parentheses is valid by using a stack to track opening brackets and ensuring that each closing bracket corresponds to the most recent unmatched opening bracket. It iterates through each character in the string, pushing opening brackets onto the stack and popping from the stack when a closing bracket is encountered. If a closing bracket does not match the expected opening bracket or if there are unmatched opening brackets left in the stack at the end, the function returns False. If all brackets are matched correctly, it returns True. The function effectively handles different types of brackets, including parentheses, curly braces, and square brackets. Overall, it ensures that the brackets are properly nested and closed.\n\n[end of description]\n"
    },
    "evaluate_postfix": {
        "code": "\n\ndef evaluate_postfix(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(int(token))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            if (token == '+'):\n                result = (a + b)\n            elif (token == '-'):\n                result = (a - b)\n            elif (token == '*'):\n                result = (a * b)\n            elif (token == '/'):\n                result = int((a / b))\n            stack.append(result)\n    return stack.pop()\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings representing a postfix expression (Reverse Polish Notation) and returns the evaluated result as an integer. The function should use a stack to evaluate the expression.",
        "description": "\n[description for function: evaluate_postfix]\nThis function evaluates a postfix expression represented as a list of tokens. It uses a stack to store operands and processes each token in the expression sequentially. When a digit is encountered, it is pushed onto the stack, while operators trigger the popping of the top two operands for computation. The result of the operation is then pushed back onto the stack. At the end of the evaluation, the final result is returned from the stack. This allows for the calculation of expressions in postfix notation efficiently.\n\n[end of description]\n"
    },
    "second_largest_unique": {
        "code": "\n\ndef second_largest_unique(nums):\n    unique_nums = set(nums)\n    if (len(unique_nums) < 2):\n        return None\n    sorted_unique_nums = sorted(unique_nums, reverse=True)\n    return sorted_unique_nums[1]\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the second largest unique integer in the list. If there is no such integer, return None. This task will help you practice using sets for unique elements and sorting techniques.",
        "description": "\n[description for function: second_largest_unique]\nThis function takes a list of numbers as input and identifies the second largest unique number from that list. It first converts the list into a set to eliminate any duplicates. If there are fewer than two unique numbers, it returns None. The unique numbers are then sorted in descending order. Finally, the function returns the second element from this sorted list, which corresponds to the second largest unique number.\n\n[end of description]\n"
    },
    "index_tracker": {
        "code": "\n\ndef index_tracker(int_list):\n    index_dict = {}\n    for (index, value) in enumerate(int_list):\n        if (value not in index_dict):\n            index_dict[value] = []\n        index_dict[value].append(index)\n    return index_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a dictionary where the keys are the integers and the values are lists of indices where each integer appears in the list. This will help practice using dictionaries to store lists and track multiple occurrences of elements.",
        "description": "\n[description for function: index_tracker]\nThis function takes a list of integers as input and creates a dictionary that maps each unique integer to a list of its indices in the original list. It iterates through the list while keeping track of both the index and the value of each element. If a value is encountered for the first time, it initializes an empty list for that value in the dictionary. The current index is then appended to the list corresponding to that value. Finally, the function returns the dictionary containing the integer-to-index mappings. This allows for easy retrieval of all positions of each integer in the input list.\n\n[end of description]\n"
    },
    "first_unique_character": {
        "code": "\n\ndef first_unique_character(s):\n    char_count = {}\n    for char in s:\n        if (char in char_count):\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if (char_count[char] == 1):\n            return char\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the first unique character in it. Use a dictionary to count the occurrences of each character. If there is no unique character, return None.",
        "description": "\n[description for function: first_unique_character]\nThis function takes a string as input and counts the occurrences of each character in it. It uses a dictionary to store the count of each character. After counting, it iterates through the string again to find the first character that appears only once. If such a character is found, it is returned; otherwise, the function returns None. The function effectively identifies the first unique character in the given string.\n\n[end of description]\n"
    },
    "sum_of_tree": {
        "code": "\n\ndef sum_of_tree(tree):\n    if (not tree):\n        return 0\n    current_value = tree[0]\n    left_sum = (sum_of_tree(tree[1]) if (len(tree) > 1) else 0)\n    right_sum = (sum_of_tree(tree[2]) if (len(tree) > 2) else 0)\n    return ((current_value + left_sum) + right_sum)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a binary tree (represented as a nested list) and returns the sum of all its nodes. The binary tree is represented as a list where the first element is the root value, the second element is the left subtree, and the third element is the right subtree. If a subtree is empty, it is represented as an empty list.",
        "description": "\n[description for function: sum_of_tree]\nThis function calculates the sum of all values in a binary tree represented as a nested list, where the first element is the root value, the second element is the left subtree, and the third element is the right subtree. It first checks if the tree is empty, returning 0 if so. Then, it retrieves the current node's value and recursively computes the sums of the left and right subtrees. Finally, it returns the total sum by adding the current value to the sums of the left and right subtrees. The function effectively traverses the tree in a depth-first manner to accumulate the total sum.\n\n[end of description]\n"
    },
    "bfs_traversal": {
        "code": "from collections import deque\n\ndef bfs_traversal(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    order_of_visit = []\n    while queue:\n        current_node = queue.popleft()\n        order_of_visit.append(current_node)\n        for neighbor in graph[current_node]:\n            if (neighbor not in visited):\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return order_of_visit\n",
        "dependencies": [],
        "task": "Write a Python function that performs a breadth-first search (BFS) on a graph represented as an adjacency list. The function should take the graph and a starting node as inputs and return a list of nodes in the order they are visited.",
        "description": "\n[description for function: bfs_traversal]\nThis function performs a breadth-first search (BFS) traversal on a given graph starting from a specified node, returning the order in which nodes are visited. It initializes a set to keep track of visited nodes and a queue to manage the nodes to be explored. As it processes each node, it adds unvisited neighbors to the queue and marks them as visited. The traversal continues until all reachable nodes have been explored. Finally, it returns a list representing the sequence of nodes visited during the traversal. This approach ensures that nodes are explored level by level.\n\n[end of description]\n"
    },
    "find_pattern_index": {
        "code": "\n\ndef find_pattern_index(main_string, pattern):\n    main_length = len(main_string)\n    pattern_length = len(pattern)\n    if (pattern_length == 0):\n        return 0\n    for i in range(((main_length - pattern_length) + 1)):\n        if (main_string[i:(i + pattern_length)] == pattern):\n            return i\n    return (- 1)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and a pattern (both strings) and returns the starting index of the first occurrence of the pattern in the string. If the pattern is not found, return -1. This will help practice string manipulation and searching techniques.",
        "description": "\n[description for function: find_pattern_index]\nThis function searches for the first occurrence of a specified pattern within a given main string. It calculates the lengths of both the main string and the pattern, returning 0 if the pattern is empty. The function iterates through the main string, checking each substring of the same length as the pattern for a match. If a match is found, it returns the starting index of the pattern within the main string. If no match is found after checking all possible positions, it returns -1. This effectively allows for a straightforward substring search.\n\n[end of description]\n"
    },
    "sum_of_evens": {
        "code": "\n\ndef sum_of_evens(numbers):\n    total = 0\n    for number in numbers:\n        if ((number % 2) == 0):\n            total += number\n    return total\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of all even numbers in the list. This task will help practice iterating through lists and applying conditional logic.",
        "description": "\n[description for function: sum_of_evens]\nThis function takes a list of numbers as input and calculates the sum of all even numbers within that list. It initializes a total variable to zero and iterates through each number in the input list. For each number, it checks if the number is even by using the modulus operator. If the number is even, it adds it to the total. Finally, the function returns the computed total of even numbers. The result is the sum of all even integers found in the provided list.\n\n[end of description]\n"
    },
    "find_perfect_squares": {
        "code": "\n\ndef find_perfect_squares(n):\n    squares = []\n    i = 1\n    while True:\n        square = (i * i)\n        if (square < n):\n            squares.append(square)\n        else:\n            break\n        i += 1\n    return squares\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns a list of all perfect squares less than n. A perfect square is an integer that is the square of an integer. This task will help practice loops, conditionals, and understanding of number properties.",
        "description": "\n[description for function: find_perfect_squares]\nThis function generates a list of perfect squares that are less than a given integer n. It initializes an empty list to store the squares and uses a loop to calculate the square of consecutive integers starting from 1. If the calculated square is less than n, it adds the square to the list; otherwise, it breaks the loop. The process continues until the square exceeds or equals n. Finally, it returns the list of perfect squares found.\n\n[end of description]\n"
    },
    "next_greater_elements": {
        "code": "\n\ndef next_greater_elements(nums):\n    result = ([(- 1)] * len(nums))\n    stack = []\n    for i in range(len(nums)):\n        while (stack and (nums[i] > nums[stack[(- 1)]])):\n            index = stack.pop()\n            result[index] = nums[i]\n        stack.append(i)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the next greater element for each element in the list. The next greater element for an element x is the first greater element on the right side of x in the list. If no such element exists, return -1 for that position.",
        "description": "\n[description for function: next_greater_elements]\nThis function takes a list of integers as input and returns a new list where each element is replaced by the next greater element in the original list. If no greater element exists for a particular position, it is replaced with -1. The function uses a stack to keep track of indices of the elements as it iterates through the list. For each element, it checks if it is greater than the element at the index stored at the top of the stack, and if so, it updates the result list accordingly. The process continues until all elements have been processed. The final result is a list of the next greater elements or -1 where applicable.\n\n[end of description]\n"
    },
    "find_missing_number": {
        "code": "\n\ndef find_missing_number(nums):\n    n = (len(nums) + 1)\n    expected_sum = ((n * (n + 1)) // 2)\n    actual_sum = sum(nums)\n    missing_number = (expected_sum - actual_sum)\n    return missing_number\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of n-1 integers in the range from 1 to n and returns the missing number. The list will not contain any duplicates.",
        "description": "\n[description for function: find_missing_number]\nThis function calculates the missing number from a sequence of integers ranging from 1 to n, where n is the length of the input list plus one. It first determines the expected sum of the complete sequence using the formula for the sum of the first n natural numbers. Then, it computes the actual sum of the numbers present in the input list. By subtracting the actual sum from the expected sum, it identifies the missing number. Finally, the function returns this missing number as the output.\n\n[end of description]\n"
    },
    "insertion_sort": {
        "code": "\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        current_value = arr[i]\n        position = i\n        while ((position > 0) and (arr[(position - 1)] > current_value)):\n            arr[position] = arr[(position - 1)]\n            position -= 1\n        arr[position] = current_value\n    return arr\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the list of integers sorted in ascending order using the insertion sort algorithm. This will help you practice implementing a classic sorting algorithm and understanding its iterative nature.",
        "description": "\n[description for function: insertion_sort]\nThis function sorts a list of elements in ascending order using the insertion sort algorithm. It iterates through each element in the list, comparing it with the elements before it and shifting those elements to the right until the correct position for the current element is found. The current element is then placed in its appropriate position, effectively building a sorted portion of the list incrementally. The process continues until all elements have been processed. Finally, the sorted list is returned. This algorithm has a time complexity of O(n^2) in the average and worst cases.\n\n[end of description]\n"
    },
    "sum_of_odds": {
        "code": "\n\ndef sum_of_odds(numbers):\n    total = 0\n    for number in numbers:\n        if ((number % 2) != 0):\n            total += number\n    return total\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of all odd numbers in the list. This task will help practice iterating through lists and applying conditional logic.",
        "description": "\n[description for function: sum_of_odds]\nThis function calculates the sum of all odd numbers in a given list. It initializes a total variable to zero and iterates through each number in the list. For each number, it checks if the number is odd by using the modulus operator. If the number is odd, it adds it to the total. Finally, the function returns the accumulated total of odd numbers. This allows users to easily find the sum of odd integers from a collection of numbers.\n\n[end of description]\n"
    },
    "selection_sort": {
        "code": "\n\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_index = i\n        for j in range((i + 1), n):\n            if (arr[j] < arr[min_index]):\n                min_index = j\n        (arr[i], arr[min_index]) = (arr[min_index], arr[i])\n    return arr\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the list of integers sorted in ascending order using the selection sort algorithm. This will help you practice implementing a classic sorting algorithm and understanding its iterative nature.",
        "description": "\n[description for function: selection_sort]\nThis function sorts an array in ascending order using the selection sort algorithm. It iterates through the array, selecting the minimum element from the unsorted portion and swapping it with the first unsorted element. The process is repeated for each element until the entire array is sorted. The function modifies the original array in place and returns the sorted array. It has a time complexity of O(n^2), making it less efficient for large datasets. Overall, it provides a straightforward method for sorting a list of comparable elements.\n\n[end of description]\n"
    },
    "max_subarray_sum": {
        "code": "\n\ndef max_subarray_sum(arr):\n    if (not arr):\n        return 0\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for num in arr[1:]:\n        current_sum = max(num, (current_sum + num))\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the maximum sum of any contiguous subarray. This will help practice iterating through lists and understanding dynamic programming concepts.",
        "description": "\n[description for function: max_subarray_sum]\nThis function calculates the maximum sum of a contiguous subarray within a given list of integers. It initializes two variables to track the maximum sum found and the current sum of the subarray being evaluated. As it iterates through the array, it updates the current sum by either starting a new subarray with the current number or adding the current number to the existing sum. It simultaneously updates the maximum sum if the current sum exceeds the previously recorded maximum. The function returns the highest sum found after evaluating all elements in the array. If the input array is empty, it returns 0.\n\n[end of description]\n"
    },
    "product_of_list": {
        "code": "\n\ndef product_of_list(int_list):\n    if (not int_list):\n        return 1\n    product = 1\n    for num in int_list:\n        product *= num\n    return product\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the product of all the integers in the list. If the list is empty, return 1.",
        "description": "\n[description for function: product_of_list]\nThis function calculates the product of all integers in a given list. If the list is empty, it returns 1 as the multiplicative identity. It initializes a variable to hold the product and iterates through each integer in the list, multiplying them together. Finally, it returns the computed product. The function effectively handles both empty and non-empty lists.\n\n[end of description]\n"
    },
    "sum_of_primes": {
        "code": "\n\ndef is_prime(n):\n    if (n < 2):\n        return False\n    for i in range(2, (int((n ** 0.5)) + 1)):\n        if ((n % i) == 0):\n            return False\n    return True\n\n\n\n\ndef sum_of_primes(numbers):\n    total = 0\n    for number in numbers:\n        if is_prime(number):\n            total += number\n    return total\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of all prime numbers in the list. This task will help practice loops, conditionals, and understanding of prime numbers.",
        "description": "\n[description for function: sum_of_primes]\nThis function calculates the sum of all prime numbers in a given list of integers. It initializes a total variable to zero and iterates through each number in the input list. For each number, it checks if it is prime using a separate function. If the number is prime, it adds it to the total. Finally, it returns the accumulated total of prime numbers.\n\n[end of description]\n"
    },
    "sorted_intersection": {
        "code": "\n\ndef sorted_intersection(list1, list2):\n    (pointer1, pointer2) = (0, 0)\n    result = set()\n    while ((pointer1 < len(list1)) and (pointer2 < len(list2))):\n        if (list1[pointer1] == list2[pointer2]):\n            result.add(list1[pointer1])\n            pointer1 += 1\n            pointer2 += 1\n        elif (list1[pointer1] < list2[pointer2]):\n            pointer1 += 1\n        else:\n            pointer2 += 1\n    return sorted(result)\n",
        "dependencies": [],
        "task": "Write a Python function that takes two sorted lists of integers and returns a list of their intersection. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: sorted_intersection]\nThis function takes two sorted lists as input and finds their intersection, returning a sorted list of unique elements that appear in both lists. It uses two pointers to traverse each list simultaneously, adding elements to a set when they match. If an element in the first list is smaller, it advances the pointer for the first list, and if the element in the second list is smaller, it advances the pointer for the second list. The use of a set ensures that only unique elements are stored. Finally, the result is converted to a sorted list before being returned. This approach efficiently finds common elements while maintaining the order.\n\n[end of description]\n"
    },
    "find_majority_element": {
        "code": "\n\ndef find_majority_element(nums):\n    n = len(nums)\n    count = {}\n    for num in nums:\n        if (num in count):\n            count[num] += 1\n        else:\n            count[num] = 1\n    majority_threshold = (n / 2)\n    for (num, cnt) in count.items():\n        if (cnt > majority_threshold):\n            return num\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the majority element. The majority element is the element that appears more than n/2 times in the list, where n is the length of the list. If no such element exists, return None.",
        "description": "\n[description for function: find_majority_element]\nThis function identifies the majority element in a list of numbers, which is defined as an element that appears more than half the time in the list. It first counts the occurrences of each number using a dictionary. After counting, it calculates the majority threshold as half the length of the list. It then checks each number's count against this threshold. If a number exceeds the threshold, it is returned as the majority element. If no majority element exists, the function returns None.\n\n[end of description]\n"
    },
    "sum_of_multiples": {
        "code": "\n\ndef sum_of_multiples(numbers):\n    total_sum = 0\n    for number in numbers:\n        if (((number % 3) == 0) or ((number % 5) == 0)):\n            total_sum += number\n    return total_sum\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of all integers that are multiples of 3 or 5. This will help practice iterating through lists and applying conditional logic.",
        "description": "\n[description for function: sum_of_multiples]\nThis function calculates the sum of all numbers in a given list that are multiples of either 3 or 5. It initializes a total sum to zero and iterates through each number in the list. For each number, it checks if it is divisible by 3 or 5. If the condition is met, the number is added to the total sum. Finally, the function returns the computed total sum. This effectively provides the sum of all qualifying multiples from the input list.\n\n[end of description]\n"
    },
    "merge_sort": {
        "code": "\n\ndef merge(left, right):\n    sorted_list = []\n    i = j = 0\n    while ((i < len(left)) and (j < len(right))):\n        if (left[i] < right[j]):\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n    return sorted_list\n\n\n\n\ndef merge_sort(arr):\n    if (len(arr) <= 1):\n        return arr\n    mid = (len(arr) // 2)\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    sorted_left = merge_sort(left_half)\n    sorted_right = merge_sort(right_half)\n    return merge(sorted_left, sorted_right)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the list of integers sorted in ascending order using the merge sort algorithm. This will help you practice implementing a classic sorting algorithm and understanding its recursive nature.",
        "description": "\n[description for function: merge_sort]\nThis function sorts an array using the merge sort algorithm, which is a divide-and-conquer approach. It first checks if the array has one or fewer elements, in which case it is already sorted and returned. If the array has more elements, it splits the array into two halves and recursively sorts each half. After sorting both halves, it merges them back together in sorted order. The merging process involves comparing elements from both halves and combining them into a new sorted list. The final result is a fully sorted array.\n\n[end of description]\n"
    },
    "longest_common_prefix": {
        "code": "\n\ndef longest_common_prefix(strs):\n    if (not strs):\n        return ''\n    prefix = strs[0]\n    for string in strs[1:]:\n        while (not string.startswith(prefix)):\n            prefix = prefix[:(- 1)]\n            if (not prefix):\n                return ''\n    return prefix\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns the longest common prefix among them. If there is no common prefix, return an empty string.",
        "description": "\n[description for function: longest_common_prefix]\nThis function finds the longest common prefix among a list of strings. It starts by checking if the list is empty and returns an empty string if so. The first string in the list is initially considered as the prefix. It then iterates through the remaining strings, reducing the prefix until it matches the start of each string. If at any point the prefix becomes empty, it returns an empty string. Finally, it returns the longest common prefix found.\n\n[end of description]\n"
    },
    "depth_first_search": {
        "code": "\n\ndef depth_first_search(graph, start):\n    visited = set()\n    result = []\n\n    def dfs_helper(node):\n        if (node not in visited):\n            visited.add(node)\n            result.append(node)\n            for neighbor in graph[node]:\n                dfs_helper(neighbor)\n    dfs_helper(start)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that performs a depth-first search (DFS) on a graph represented as an adjacency list. The function should take the graph and a starting node as inputs and return a list of nodes in the order they are visited.",
        "description": "\n[description for function: depth_first_search]\nThis function performs a depth-first search (DFS) on a given graph starting from a specified node. It initializes a set to keep track of visited nodes and a list to store the traversal order. The search explores as far as possible along each branch before backtracking. For each unvisited node, it marks it as visited and adds it to the result list. The function ultimately returns the list of nodes in the order they were visited. This approach is useful for exploring all reachable nodes in a graph.\n\n[end of description]\n"
    },
    "sum_of_squares_of_evens": {
        "code": "\n\ndef sum_of_squares_of_evens(numbers):\n    total_sum = 0\n    for number in numbers:\n        if ((number % 2) == 0):\n            total_sum += (number ** 2)\n    return total_sum\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of the squares of all even numbers in the list. This will help practice iterating through lists, applying conditional logic, and performing arithmetic operations.",
        "description": "\n[description for function: sum_of_squares_of_evens]\nThis function calculates the sum of the squares of all even numbers in a given list. It initializes a total sum to zero and iterates through each number in the list. For each number, it checks if the number is even by using the modulus operator. If the number is even, its square is added to the total sum. Finally, the function returns the computed total sum of the squares of the even numbers.\n\n[end of description]\n"
    },
    "fibonacci_less_than_n": {
        "code": "\n\ndef fibonacci_less_than_n(n):\n    fib_list = []\n    (a, b) = (0, 1)\n    while (a < n):\n        fib_list.append(a)\n        (a, b) = (b, (a + b))\n    return fib_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns a list of all Fibonacci numbers less than n. This will help practice loops, conditionals, and understanding of number sequences.",
        "description": "\n[description for function: fibonacci_less_than_n]\nThis function generates a list of Fibonacci numbers that are less than a specified integer, n. It initializes two variables to represent the first two Fibonacci numbers and iteratively calculates the next Fibonacci number by summing the previous two. As long as the current Fibonacci number is less than n, it appends that number to the list. Once a Fibonacci number reaches or exceeds n, the loop terminates. Finally, the function returns the list of Fibonacci numbers collected during the process.\n\n[end of description]\n"
    },
    "find_smallest_difference_pair": {
        "code": "\n\ndef find_smallest_difference_pair(nums):\n    nums.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    for i in range((len(nums) - 1)):\n        diff = abs((nums[i] - nums[(i + 1)]))\n        if (diff < min_diff):\n            min_diff = diff\n            closest_pair = (nums[i], nums[(i + 1)])\n    return closest_pair\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the two integers that have the smallest absolute difference. If there are multiple pairs with the same smallest difference, return any one of them.",
        "description": "\n[description for function: find_smallest_difference_pair]\nThis function takes a list of numbers, sorts it, and then finds the pair of adjacent numbers with the smallest absolute difference, returning that pair. It initializes a variable to track the minimum difference and the closest pair found. As it iterates through the sorted list, it calculates the difference between each pair of adjacent numbers. If a smaller difference is found, it updates the minimum difference and the closest pair. Finally, it returns the pair of numbers that have the smallest difference. The function effectively identifies the closest values in the input list.\n\n[end of description]\n"
    },
    "product_of_odds": {
        "code": "\n\ndef product_of_odds(numbers):\n    product = 1\n    for number in numbers:\n        if ((number % 2) != 0):\n            product *= number\n    return product\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the product of all odd numbers in the list. If there are no odd numbers, return 1.",
        "description": "\n[description for function: product_of_odds]\nThis function calculates the product of all odd numbers in a given list. It initializes a variable to store the product, starting at 1. It then iterates through each number in the input list, checking if the number is odd. If a number is odd, it multiplies it with the current product. Finally, the function returns the resulting product of the odd numbers. If there are no odd numbers, the function will return 1.\n\n[end of description]\n"
    },
    "longest_equal_subarray": {
        "code": "\n\ndef longest_equal_subarray(arr):\n    if (not arr):\n        return 0\n    max_length = 1\n    current_length = 1\n    for i in range(1, len(arr)):\n        if (arr[i] == arr[(i - 1)]):\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n    max_length = max(max_length, current_length)\n    return max_length\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the length of the longest contiguous subarray with all elements equal. This will help practice iterating through lists and applying conditional logic to track sequences.",
        "description": "\n[description for function: longest_equal_subarray]\nThis function takes an array as input and determines the length of the longest contiguous subarray where all elements are equal. It initializes two variables to track the maximum length found and the current length of equal elements. As it iterates through the array, it compares each element to the previous one, incrementing the current length if they are equal. If they are not equal, it updates the maximum length if the current length is greater and resets the current length. After completing the iteration, it performs a final check to ensure the maximum length is updated if the longest equal subarray is at the end of the array. The function returns the length of the longest equal subarray found.\n\n[end of description]\n"
    },
    "find_k_smallest": {
        "code": "import heapq\n\ndef find_k_smallest(nums, k):\n    return heapq.nsmallest(k, nums)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the k smallest elements in ascending order. Use a min-heap to efficiently find the k smallest elements.",
        "description": "\n[description for function: find_k_smallest]\nThis function takes a list of numbers and an integer k as input, and it returns the k smallest elements from the list. It utilizes a heap data structure to efficiently find the smallest elements. The function leverages the `nsmallest` method from the `heapq` module, which ensures optimal performance. The result is a list containing the k smallest numbers in ascending order. If k is greater than the number of elements in the list, it will return all available elements. Overall, it provides a straightforward way to retrieve the smallest values from a collection of numbers.\n\n[end of description]\n"
    },
    "sum_of_multiples_of_seven": {
        "code": "\n\ndef sum_of_multiples_of_seven(int_list):\n    total_sum = 0\n    for num in int_list:\n        if ((num % 7) == 0):\n            total_sum += num\n    return total_sum\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of all integers that are multiples of 7. This will help practice iterating through lists and applying conditional logic.",
        "description": "\n[description for function: sum_of_multiples_of_seven]\nThis function calculates the sum of all numbers in a given list that are multiples of seven. It initializes a total sum variable to zero and iterates through each number in the list. For each number, it checks if it is divisible by seven. If it is, the number is added to the total sum. Finally, the function returns the computed total sum of the multiples of seven.\n\n[end of description]\n"
    },
    "calculate_lcm": {
        "code": "from functools import reduce\n\ndef gcd(a, b):\n    while (b != 0):\n        (a, b) = (b, (a % b))\n    return a\n\n\n\n\ndef lcm(a, b):\n    return (abs((a * b)) // gcd(a, b))\n\n\n\n\ndef calculate_lcm(numbers):\n    if (not numbers):\n        return None\n    return reduce(lcm, numbers)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the least common multiple (LCM) of the numbers in the list. Use the relationship between LCM and GCD to compute the LCM efficiently.",
        "description": "\n[description for function: calculate_lcm]\nThis function computes the least common multiple (LCM) of a list of numbers. If the input list is empty, it returns None. It utilizes the reduce function to apply the LCM calculation iteratively across the list. The LCM is determined by using the absolute product of the numbers divided by their greatest common divisor (GCD). The function effectively handles multiple numbers, returning the overall LCM.\n\n[end of description]\n"
    },
    "find_k_largest_v2": {
        "code": "import heapq\n\ndef find_k_largest_v2(nums, k):\n    max_heap = [(- num) for num in nums]\n    heapq.heapify(max_heap)\n    largest_elements = []\n    for _ in range(min(k, len(nums))):\n        largest_elements.append((- heapq.heappop(max_heap)))\n    return sorted(largest_elements, reverse=True)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the k largest elements in descending order. Use a max-heap to efficiently find the k largest elements.",
        "description": "\n[description for function: find_k_largest]\nThis function takes a list of numbers and an integer k as input, and it finds the k largest elements from the list. It first creates a max heap by negating the numbers, allowing the use of Python's min-heap implementation to simulate a max-heap. The function then extracts the largest elements from the heap, ensuring that it does not exceed the number of available elements. The extracted elements are collected in a list, which is then sorted in descending order before being returned. This approach efficiently retrieves the largest elements while maintaining the order. The final output is a sorted list of the k largest numbers from the input list.\n\n[end of description]\n"
    },
    "generate_permutations": {
        "code": "from itertools import permutations\n\ndef generate_permutations(int_list):\n    return [list(p) for p in permutations(int_list)]\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of all possible permutations of the integers. Each permutation should be represented as a list of integers.",
        "description": "\n[description for function: generate_permutations]\nThis function takes a list of integers as input and generates all possible permutations of the elements in that list. It utilizes the permutations function from the itertools module to create these arrangements. Each permutation is returned as a list, resulting in a list of lists containing all unique permutations. The output will include every possible ordering of the input integers. This function is useful for scenarios where different arrangements of a set of items are needed. The final result is a comprehensive collection of all permutations of the provided integer list.\n\n[end of description]\n"
    },
    "sum_of_digits": {
        "code": "\n\ndef sum_of_digits(n):\n    total = 0\n    for digit in str(n):\n        total += int(digit)\n    return total\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer and returns the sum of its digits. This will help practice loops and arithmetic operations.",
        "description": "\n[description for function: sum_of_digits]\nThis function calculates the sum of the digits of a given integer. It converts the integer into a string to iterate over each digit. Each digit is then converted back to an integer and added to a running total. Finally, the function returns the total sum of the digits. It effectively handles any non-negative integer input. The result provides a simple way to analyze the individual components of the number.\n\n[end of description]\n"
    },
    "longest_increasing_subsequence": {
        "code": "\n\ndef longest_increasing_subsequence(nums):\n    if (not nums):\n        return 0\n    n = len(nums)\n    dp = ([1] * n)\n    for i in range(1, n):\n        for j in range(i):\n            if (nums[i] > nums[j]):\n                dp[i] = max(dp[i], (dp[j] + 1))\n    return max(dp)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the length of the longest increasing subsequence. Use dynamic programming to solve this problem efficiently.",
        "description": "\n[description for function: longest_increasing_subsequence]\nThis function calculates the length of the longest increasing subsequence in a given list of numbers. It initializes a dynamic programming array to keep track of the longest subsequence lengths at each index. The function iterates through the list, comparing each element with the previous ones to update the lengths accordingly. If a number is greater than a previous number, it updates the current index's value based on the maximum length found. Finally, it returns the maximum value from the dynamic programming array, representing the length of the longest increasing subsequence. If the input list is empty, it returns 0.\n\n[end of description]\n"
    },
    "min_path_sum": {
        "code": "\n\ndef min_path_sum(grid):\n    if ((not grid) or (not grid[0])):\n        return 0\n    (m, n) = (len(grid), len(grid[0]))\n    dp = [([0] * n) for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for j in range(1, n):\n        dp[0][j] = (dp[0][(j - 1)] + grid[0][j])\n    for i in range(1, m):\n        dp[i][0] = (dp[(i - 1)][0] + grid[i][0])\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = (min(dp[(i - 1)][j], dp[i][(j - 1)]) + grid[i][j])\n    return dp[(m - 1)][(n - 1)]\n",
        "dependencies": [],
        "task": "Write a Python function that takes a 2D grid of integers and returns the minimum path sum from the top-left corner to the bottom-right corner. You can only move down or right at any point in time.",
        "description": "\n[description for function: min_path_sum]\nThis function calculates the minimum path sum from the top-left corner to the bottom-right corner of a grid, where each cell contains a non-negative integer. It initializes a dynamic programming table to store the minimum sums at each cell, starting with the value of the top-left cell. The function iteratively fills in the first row and first column by accumulating sums from the previous cells. For the rest of the grid, it computes the minimum path sum for each cell by considering the minimum of the sums from the cell above and the cell to the left. Finally, it returns the minimum path sum found at the bottom-right corner of the grid. If the grid is empty or has no columns, it returns 0.\n\n[end of description]\n"
    },
    "prefix_sum": {
        "code": "\n\ndef prefix_sum(nums):\n    result = []\n    cumulative_sum = 0\n    for num in nums:\n        cumulative_sum += num\n        result.append(cumulative_sum)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list where each element at index i is the sum of the elements from index 0 to i in the original list. This will help practice using prefix sums.",
        "description": "\n[description for function: prefix_sum]\nThis function calculates the cumulative sum of a list of numbers. It initializes an empty list to store the results and a variable to keep track of the running total. As it iterates through each number in the input list, it adds the current number to the cumulative total and appends this total to the results list. Finally, it returns the list of cumulative sums. The output reflects the sum of all previous numbers up to each index in the input list. This is useful for quickly obtaining the sum of elements in a range.\n\n[end of description]\n"
    },
    "binary_search": {
        "code": "\n\ndef binary_search(sorted_list, target):\n    (left, right) = (0, (len(sorted_list) - 1))\n    while (left <= right):\n        mid = ((left + right) // 2)\n        if (sorted_list[mid] == target):\n            return mid\n        elif (sorted_list[mid] < target):\n            left = (mid + 1)\n        else:\n            right = (mid - 1)\n    return (- 1)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a sorted list of integers and an integer target, and returns the index of the target if it is present in the list using binary search. If the target is not present, return -1. This will help practice implementing binary search and understanding its efficiency.",
        "description": "\n[description for function: binary_search]\nThis function performs a binary search on a sorted list to find the index of a specified target value. It initializes two pointers, left and right, to represent the current search boundaries. In a loop, it calculates the midpoint and compares the target with the value at that index. If a match is found, it returns the index; if the target is greater, it narrows the search to the right half, and if it's smaller, to the left half. The process continues until the target is found or the search space is exhausted. If the target is not present, it returns -1.\n\n[end of description]\n"
    },
    "dijkstra_shortest_path": {
        "code": "import heapq\n\ndef dijkstra_shortest_path(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if (current_distance > distances[current_node]):\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = (current_distance + weight)\n            if (distance < distances[neighbor]):\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    return distances\n",
        "dependencies": [],
        "task": "Write a Python function that takes a graph represented as an adjacency list and a starting node, and returns the shortest path from the starting node to all other nodes using Dijkstra's algorithm. The graph is represented as a dictionary where keys are node identifiers and values are lists of tuples (neighbor, weight).",
        "description": "\n[description for function: dijkstra_shortest_path]\nThis function implements Dijkstra's algorithm to find the shortest path from a starting node to all other nodes in a weighted graph. It initializes distances to all nodes as infinity, except for the starting node, which is set to zero. A priority queue is used to explore the graph, processing nodes in order of their current known distance. For each node, it updates the distances to its neighbors if a shorter path is found. The process continues until all reachable nodes have been processed. Finally, it returns a dictionary containing the shortest distances from the starting node to each node in the graph.\n\n[end of description]\n"
    },
    "length_of_lis": {
        "code": "import bisect\n\ndef length_of_lis(nums):\n    dp = []\n    for num in nums:\n        index = bisect.bisect_left(dp, num)\n        if (index == len(dp)):\n            dp.append(num)\n        else:\n            dp[index] = num\n    return len(dp)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the length of the longest increasing subsequence. Use dynamic programming and binary search to solve this problem efficiently.",
        "description": "\n[description for function: length_of_lis]\nThis function calculates the length of the longest increasing subsequence in a given list of numbers. It utilizes a dynamic programming approach with binary search to efficiently maintain a list that represents the smallest possible tail values for increasing subsequences of various lengths. As it iterates through each number in the input list, it determines the appropriate position to either append the number or replace an existing value in the list. The final result is the length of this list, which corresponds to the length of the longest increasing subsequence. The use of the `bisect` module allows for efficient insertion and searching within the list. Overall, the function provides an optimal solution with a time complexity of O(n log n).\n\n[end of description]\n"
    },
    "sum_of_multiples_of_11": {
        "code": "\n\ndef sum_of_multiples_of_11(int_list):\n    total_sum = 0\n    for number in int_list:\n        if ((number % 11) == 0):\n            total_sum += number\n    return total_sum\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of all integers that are multiples of 11. This task will help practice iterating through lists and applying conditional logic.",
        "description": "\n[description for function: sum_of_multiples_of_11]\nThis function calculates the sum of all numbers in a given list that are multiples of 11. It initializes a total sum variable to zero and iterates through each number in the list. For each number, it checks if it is divisible by 11. If it is, the number is added to the total sum. Finally, the function returns the computed total sum of the multiples of 11.\n\n[end of description]\n"
    },
    "unique_paths": {
        "code": "\n\ndef unique_paths(m, n):\n    dp = [([0] * n) for _ in range(m)]\n    for i in range(m):\n        dp[i][0] = 1\n    for j in range(n):\n        dp[0][j] = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = (dp[(i - 1)][j] + dp[i][(j - 1)])\n    return dp[(m - 1)][(n - 1)]\n",
        "dependencies": [],
        "task": "Write a Python function that takes two integers, m and n, representing the dimensions of a grid, and returns the number of unique paths from the top-left corner to the bottom-right corner. You can only move down or right at any point in time.",
        "description": "\n[description for function: unique_paths]\nThis function calculates the number of unique paths from the top-left corner to the bottom-right corner of a grid with dimensions m by n, where movement is restricted to only right and down. It initializes a 2D list to store the number of ways to reach each cell in the grid. The first row and first column are filled with 1s, representing the only way to reach those cells. It then iteratively fills in the rest of the grid by summing the number of ways to reach the cell from the cell above and the cell to the left. Finally, it returns the value in the bottom-right corner of the grid, which represents the total number of unique paths. This approach utilizes dynamic programming to efficiently compute the result.\n\n[end of description]\n"
    },
    "max_product_of_three": {
        "code": "\n\ndef max_product_of_three(nums):\n    nums.sort()\n    product1 = ((nums[(- 1)] * nums[(- 2)]) * nums[(- 3)])\n    product2 = ((nums[0] * nums[1]) * nums[(- 1)])\n    return max(product1, product2)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the maximum product of any three integers in the list. This will help practice iterating through lists and understanding pairwise comparisons.",
        "description": "\n[description for function: max_product_of_three]\nThis function calculates the maximum product that can be obtained by multiplying any three numbers from a given list. It first sorts the list of numbers in ascending order. Then, it computes two potential maximum products: one using the three largest numbers and another using the two smallest numbers (which could be negative) multiplied by the largest number. Finally, it returns the greater of the two computed products. This approach ensures that both positive and negative combinations are considered for maximizing the product. The function efficiently handles the input by leveraging sorting and simple arithmetic operations.\n\n[end of description]\n"
    },
    "is_match": {
        "code": "\n\ndef is_match(s: str, p: str) -> bool:\n    (s_len, p_len) = (len(s), len(p))\n    (s_index, p_index, star_index, match_index) = (0, 0, (- 1), 0)\n    while (s_index < s_len):\n        if ((p_index < p_len) and ((p[p_index] == s[s_index]) or (p[p_index] == '?'))):\n            s_index += 1\n            p_index += 1\n        elif ((p_index < p_len) and (p[p_index] == '*')):\n            star_index = p_index\n            match_index = s_index\n            p_index += 1\n        elif (star_index != (- 1)):\n            p_index = (star_index + 1)\n            match_index += 1\n            s_index = match_index\n        else:\n            return False\n    while ((p_index < p_len) and (p[p_index] == '*')):\n        p_index += 1\n    return (p_index == p_len)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and a pattern (both strings) and returns True if the pattern matches the string using simple wildcard matching. The pattern may contain '?' which matches any single character, and '*' which matches any sequence of characters (including the empty sequence).",
        "description": "\n[description for function: is_match]\nThis function determines if a given string matches a specified pattern, where the pattern may include wildcard characters: '?' which matches any single character, and '*' which matches any sequence of characters (including an empty sequence). It uses a two-pointer approach to traverse both the string and the pattern, handling matches and wildcards accordingly. When a '*' is encountered, it records its position and attempts to match subsequent characters in the string. If a mismatch occurs, it backtracks to the last '*' and tries to match the next character in the string. After processing the string, it checks if any remaining characters in the pattern are all '*', indicating a successful match. The function returns a boolean value indicating whether the string matches the pattern.\n\n[end of description]\n"
    },
    "find_most_frequent_integer": {
        "code": "\n\ndef find_most_frequent_integer(int_list):\n    frequency_counter = {}\n    for num in int_list:\n        if (num in frequency_counter):\n            frequency_counter[num] += 1\n        else:\n            frequency_counter[num] = 1\n    most_frequent = None\n    max_count = 0\n    for (num, count) in frequency_counter.items():\n        if (count > max_count):\n            max_count = count\n            most_frequent = num\n    return most_frequent\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the integer that appears the most frequently. If there is a tie, return any one of the most frequent integers.",
        "description": "\n[description for function: find_most_frequent_integer]\nThis function takes a list of integers as input and determines which integer appears most frequently in the list. It uses a dictionary to count the occurrences of each integer. After populating the frequency counts, it iterates through the dictionary to identify the integer with the highest count. If multiple integers have the same maximum frequency, the first one encountered is returned. Finally, the function returns the most frequently occurring integer. If the input list is empty, it will return `None`.\n\n[end of description]\n"
    },
    "sum_of_multiples_of_4": {
        "code": "\n\ndef sum_of_multiples_of_4(numbers):\n    total = 0\n    for number in numbers:\n        if ((number % 4) == 0):\n            total += number\n    return total\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of all integers that are multiples of 4. This task will help practice iterating through lists and applying conditional logic.",
        "description": "\n[description for function: sum_of_multiples_of_4]\nThis function calculates the sum of all numbers in a given list that are multiples of 4. It initializes a total variable to zero and iterates through each number in the list. For each number, it checks if it is divisible by 4. If the condition is met, the number is added to the total. Finally, the function returns the accumulated total of the multiples of 4.\n\n[end of description]\n"
    }
}