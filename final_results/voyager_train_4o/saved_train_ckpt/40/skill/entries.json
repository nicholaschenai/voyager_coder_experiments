{
    "filter_even_numbers": {
        "code": "\n\ndef filter_even_numbers(input_list):\n    even_numbers = []\n    for number in input_list:\n        if ((number % 2) == 0):\n            even_numbers.append(number)\n    return even_numbers\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list containing only the even numbers from the original list.",
        "description": "\n[description for function: filter_even_numbers]\nThis function takes a list of numbers as input and iterates through each number to check if it is even. If a number is found to be even (i.e., divisible by 2 with no remainder), it is added to a new list. After processing all the numbers, the function returns the list containing only the even numbers. The output will be an array that excludes any odd numbers from the original input. This allows users to easily filter out even values from a mixed list of integers. The function effectively provides a simple way to identify and collect even numbers.\n\n[end of description]\n"
    },
    "count_string_occurrences": {
        "code": "\n\ndef count_string_occurrences(string_list):\n    count_dict = {}\n    for string in string_list:\n        if (string in count_dict):\n            count_dict[string] += 1\n        else:\n            count_dict[string] = 1\n    return count_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a dictionary where the keys are the strings and the values are the number of times each string appears in the list.",
        "description": "\n[description for function: count_string_occurrences]\nThis function takes a list of strings as input and counts the occurrences of each unique string in that list. It initializes an empty dictionary to store the counts. As it iterates through the list, it checks if each string is already a key in the dictionary; if so, it increments the count, otherwise, it adds the string with a count of one. Finally, it returns the dictionary containing the strings and their corresponding counts. This allows for easy retrieval of how many times each string appears in the input list. The function effectively summarizes the frequency of each string in the provided list.\n\n[end of description]\n"
    },
    "group_strings_by_length": {
        "code": "\n\ndef group_strings_by_length(strings):\n    length_dict = {}\n    for string in strings:\n        length = len(string)\n        if (length in length_dict):\n            length_dict[length].append(string)\n        else:\n            length_dict[length] = [string]\n    return length_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a dictionary where the keys are the lengths of the strings and the values are lists of strings of that length.",
        "description": "\n[description for function: group_strings_by_length]\nThis function takes a list of strings and organizes them into a dictionary where the keys are the lengths of the strings and the values are lists of strings that share the same length. It iterates through each string in the input list, calculates its length, and then adds it to the corresponding list in the dictionary. If a length key already exists, the string is appended to the existing list; otherwise, a new list is created for that length. Finally, the function returns the constructed dictionary, providing a clear grouping of strings by their lengths. This allows for easy access to all strings of a specific length. The output is a structured representation of the input strings based on their lengths.\n\n[end of description]\n"
    },
    "first_non_repeating_char": {
        "code": "\n\ndef first_non_repeating_char(s):\n    char_count = {}\n    for char in s:\n        char_count[char] = (char_count.get(char, 0) + 1)\n    for char in s:\n        if (char_count[char] == 1):\n            return char\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the first non-repeating character in it. If all characters repeat, return None.",
        "description": "\n[description for function: first_non_repeating_char]\nThis function takes a string as input and counts the occurrences of each character in it. It uses a dictionary to store the count of each character. After counting, it iterates through the string again to find the first character that appears only once. If such a character is found, it is returned as the result. If no non-repeating character exists, the function returns None. This effectively identifies the first unique character in the given string.\n\n[end of description]\n"
    },
    "find_pairs_with_sum": {
        "code": "from collections import Counter\n\ndef find_pairs_with_sum(nums, target):\n    from collections import Counter\n    num_count = Counter(nums)\n    unique_pairs = set()\n    for num in nums:\n        complement = (target - num)\n        if (complement in num_count):\n            if ((num == complement) and (num_count[num] < 2)):\n                continue\n            pair = (min(num, complement), max(num, complement))\n            unique_pairs.add(pair)\n    return sorted(list(unique_pairs))\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of all unique pairs (as tuples) that sum up to a given target integer. The pairs should be sorted in ascending order, and each pair should be sorted as well.",
        "description": "\n[description for function: find_pairs_with_sum]\nThis function takes a list of integers and a target sum as input, and it identifies all unique pairs of numbers from the list that add up to the target sum. It utilizes a counter to keep track of the occurrences of each number in the list. As it iterates through the numbers, it calculates the complement needed to reach the target sum and checks if it exists in the counter. If the number and its complement are the same, it ensures there are at least two occurrences of that number. The pairs are stored in a set to maintain uniqueness and are returned as a sorted list.\n\n[end of description]\n"
    },
    "longest_unique_substring": {
        "code": "\n\ndef longest_unique_substring(s):\n    char_set = set()\n    max_length = 0\n    start = 0\n    longest_substr = ''\n    for end in range(len(s)):\n        while (s[end] in char_set):\n            char_set.remove(s[start])\n            start += 1\n        char_set.add(s[end])\n        if (((end - start) + 1) > max_length):\n            max_length = ((end - start) + 1)\n            longest_substr = s[start:(end + 1)]\n    return longest_substr\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the longest substring without repeating characters.",
        "description": "\n[description for function: longest_unique_substring]\nThis function takes a string as input and finds the longest substring that contains all unique characters. It uses a sliding window approach, maintaining a set of characters currently in the substring and adjusting the start index as needed to ensure uniqueness. As it iterates through the string, it updates the maximum length and the corresponding substring whenever a longer unique substring is found. The function ultimately returns the longest substring with all unique characters. It efficiently handles the input by ensuring that each character is processed only once. The result is a single substring that meets the criteria.\n\n[end of description]\n"
    },
    "find_common_elements": {
        "code": "\n\ndef find_common_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    common_set = (set1 & set2)\n    result = sorted(common_set)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a list of their common elements. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: find_common_elements]\nThis function takes two lists as input and converts them into sets to eliminate duplicates. It then finds the intersection of these two sets, which contains the common elements. The resulting set of common elements is sorted in ascending order. Finally, the function returns this sorted list of common elements.\n\n[end of description]\n"
    },
    "bubble_sort": {
        "code": "\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range((n - 1)):\n        for j in range(((n - 1) - i)):\n            if (arr[j] > arr[(j + 1)]):\n                (arr[j], arr[(j + 1)]) = (arr[(j + 1)], arr[j])\n    return arr\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and sorts it in ascending order using the bubble sort algorithm. The function should return the sorted list.",
        "description": "\n[description for function: bubble_sort]\nThis function sorts a given list of numbers in ascending order using the bubble sort algorithm. It iterates through the list multiple times, comparing adjacent elements and swapping them if they are in the wrong order. The process is repeated until the entire list is sorted. The outer loop controls the number of passes, while the inner loop performs the comparisons and swaps. The function modifies the original list in place and returns the sorted list. Overall, it efficiently organizes the elements by repeatedly \"bubbling\" the largest unsorted element to its correct position.\n\n[end of description]\n"
    },
    "reverse_list": {
        "code": "\n\ndef reverse_list(input_list):\n    return input_list[::(- 1)]\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the elements in reverse order.",
        "description": "\n[description for function: reverse_list]\nThis function takes a list as input and returns a new list that contains the elements of the input list in reverse order. It utilizes Python's slicing feature to achieve this by specifying a step of -1. The result is a reversed version of the original list without modifying the input list itself. This approach is concise and efficient for reversing lists. The function can handle lists of any data type, including mixed types. Overall, it provides a simple way to reverse the order of elements in a list.\n\n[end of description]\n"
    },
    "find_gcd_of_list": {
        "code": "\n\ndef gcd(a, b):\n    while (b != 0):\n        (a, b) = (b, (a % b))\n    return a\n\n\n\n\ndef find_gcd_of_list(numbers):\n    if (not numbers):\n        return None\n    current_gcd = numbers[0]\n    for num in numbers[1:]:\n        current_gcd = gcd(current_gcd, num)\n    return current_gcd\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the greatest common divisor (GCD) of the numbers in the list. Use the Euclidean algorithm to find the GCD.",
        "description": "\n[description for function: find_gcd_of_list]\nThis function calculates the greatest common divisor (GCD) of a list of numbers by iteratively applying the GCD calculation to each element in the list, starting with the first number as the initial GCD. If the input list is empty, it returns None. It initializes the current GCD with the first number and then updates it by finding the GCD with each subsequent number in the list. Finally, it returns the computed GCD for the entire list.\n\n[end of description]\n"
    },
    "remove_vowels": {
        "code": "\n\ndef remove_vowels(input_string):\n    vowels = 'aeiouAEIOU'\n    result = []\n    for char in input_string:\n        if (char not in vowels):\n            result.append(char)\n    return ''.join(result)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns a new string with all the vowels removed. The function should be case-insensitive, meaning it should remove both uppercase and lowercase vowels.",
        "description": "\n[description for function: remove_vowels]\nThis function takes a string as input and removes all vowels from it, including both uppercase and lowercase letters. It initializes an empty list to store the characters that are not vowels. As it iterates through each character in the input string, it checks if the character is not a vowel and, if so, appends it to the result list. Finally, it joins the characters in the result list into a single string and returns that string without vowels.\n\n[end of description]\n"
    },
    "common_elements": {
        "code": "\n\ndef common_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    common_set = (set1 & set2)\n    return list(common_set)\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a list of integers that are present in both lists, without duplicates. Use set operations to achieve this.",
        "description": "\n[description for function: common_elements]\nThis function takes two lists as input and converts them into sets to eliminate any duplicate values. It then computes the intersection of these two sets to identify the common elements present in both lists. Finally, it returns the common elements as a new list. The use of sets ensures that the operation is efficient and that the result contains unique values. The output will only include elements that appear in both input lists. Overall, it provides a straightforward way to find shared items between two collections.\n\n[end of description]\n"
    },
    "simulate_stack_operations": {
        "code": "\n\ndef simulate_stack_operations(operations):\n    stack = []\n    results = []\n    for operation in operations:\n        if operation.startswith('push'):\n            (_, value) = operation.split()\n            stack.append(int(value))\n        elif (operation == 'pop'):\n            if stack:\n                results.append(stack.pop())\n            else:\n                results.append(None)\n        elif (operation == 'peek'):\n            if stack:\n                results.append(stack[(- 1)])\n            else:\n                results.append(None)\n    return results\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of operations (as strings) and simulates a stack using a list. The operations can be 'push X' to push an integer X onto the stack, 'pop' to remove the top element, and 'peek' to return the top element without removing it. The function should return a list of results from the 'pop' and 'peek' operations.",
        "description": "\n[description for function: simulate_stack_operations]\nThis function simulates a series of stack operations based on a list of commands. It initializes an empty stack and processes each operation, which can be to push a value onto the stack, pop the top value off the stack, or peek at the top value without removing it. When pushing, it converts the value to an integer before adding it to the stack. If a pop or peek operation is attempted on an empty stack, it appends `None` to the results list. The function returns a list of results corresponding to the pop and peek operations. Overall, it effectively manages stack behavior and provides feedback on the operations performed.\n\n[end of description]\n"
    },
    "symmetric_difference": {
        "code": "\n\ndef symmetric_difference(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    result_set = (set1 ^ set2)\n    result_list = sorted(result_set)\n    return result_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a list of integers that are present in either of the lists but not in both. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: symmetric_difference]\nThis function calculates the symmetric difference between two lists by converting them into sets, which allows for the identification of elements that are unique to each set. It uses the symmetric difference operator to find elements that are in either of the sets but not in both. The resulting set is then sorted to produce a list of the unique elements in ascending order. Finally, the function returns this sorted list. This provides a clear and efficient way to determine the unique elements from two input lists.\n\n[end of description]\n"
    },
    "count_integers": {
        "code": "\n\ndef count_integers(int_list):\n    count_dict = {}\n    for num in int_list:\n        if (num in count_dict):\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a dictionary where the keys are the integers and the values are the number of times each integer appears in the list. This will help practice using dictionaries for counting occurrences.",
        "description": "\n[description for function: count_integers]\nThis function takes a list of integers as input and counts the occurrences of each integer in the list. It initializes an empty dictionary to store the counts. As it iterates through the list, it updates the count for each integer, either by incrementing the existing count or initializing it to one if the integer is encountered for the first time. Finally, it returns the dictionary containing the integers and their corresponding counts. This allows for a quick overview of how many times each integer appears in the input list. The function effectively provides a frequency distribution of the integers.\n\n[end of description]\n"
    },
    "find_primes_less_than": {
        "code": "\n\ndef find_primes_less_than(n):\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, (int((num ** 0.5)) + 1)):\n            if ((num % i) == 0):\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns a list of all prime numbers less than n. This will help you practice loops, conditionals, and understanding of prime numbers.",
        "description": "\n[description for function: find_primes_less_than]\nThis function generates a list of all prime numbers that are less than a specified integer, n. It iterates through each number starting from 2 up to n-1 and checks if the number is prime by testing divisibility with all integers up to its square root. If a number is found to be prime, it is added to the list of primes. The function ultimately returns the complete list of prime numbers found. It efficiently determines primality by reducing the number of divisibility checks needed. The result is a collection of prime numbers that can be used for various mathematical applications.\n\n[end of description]\n"
    },
    "is_pattern_in_string": {
        "code": "\n\ndef is_pattern_in_string(main_string, pattern):\n    return (pattern in main_string)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and a pattern (both strings) and returns True if the pattern is found in the string, and False otherwise. The function should perform a simple substring search.",
        "description": "\n[description for function: is_pattern_in_string]\nThis function checks if a specified pattern exists within a given main string. It takes two arguments: the main string and the pattern to search for. The function utilizes the 'in' operator to determine if the pattern is a substring of the main string. It returns a boolean value, either True or False, based on the presence of the pattern. This allows for quick and efficient substring searching. Overall, it provides a straightforward way to verify the existence of a sequence of characters within another string.\n\n[end of description]\n"
    },
    "recursive_factorial": {
        "code": "\n\ndef recursive_factorial(n):\n    if (n == 0):\n        return 1\n    else:\n        return (n * recursive_factorial((n - 1)))\n",
        "dependencies": [],
        "task": "Write a Python function that calculates the factorial of a given non-negative integer using recursion. The function should return the factorial value.",
        "description": "\n[description for function: recursive_factorial]\nThis function calculates the factorial of a non-negative integer using recursion. If the input is zero, it returns 1, as the factorial of zero is defined to be 1. For any positive integer, it multiplies the integer by the factorial of the integer minus one, effectively reducing the problem size with each recursive call. The process continues until it reaches the base case of zero. The final result is the product of all integers from the input down to one. This approach elegantly demonstrates the concept of recursion in programming.\n\n[end of description]\n"
    },
    "find_max_index": {
        "code": "\n\ndef find_max_index(nums):\n    if (not nums):\n        return (- 1)\n    max_value = nums[0]\n    max_index = 0\n    for index in range(len(nums)):\n        if (nums[index] > max_value):\n            max_value = nums[index]\n            max_index = index\n    return max_index\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the index of the first occurrence of the maximum value in the list. If the list is empty, return -1.",
        "description": "\n[description for function: find_max_index]\nThis function takes a list of numbers as input and returns the index of the maximum value in the list. If the list is empty, it returns -1. It initializes the maximum value and its index with the first element of the list. It then iterates through the list, updating the maximum value and its index whenever a larger value is found. Finally, it returns the index of the maximum value. The function effectively identifies the position of the highest number in the provided list.\n\n[end of description]\n"
    },
    "find_k_largest": {
        "code": "import heapq\n\ndef find_k_largest(nums, k):\n    if (k > len(nums)):\n        return sorted(nums, reverse=True)\n    min_heap = []\n    for num in nums:\n        if (len(min_heap) < k):\n            heapq.heappush(min_heap, num)\n        elif (num > min_heap[0]):\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, num)\n    return sorted(min_heap, reverse=True)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of the k largest elements in descending order. Use a min-heap to efficiently find the k largest elements.",
        "description": "\n[description for function: find_k_largest]\nThis function identifies the k largest elements from a given list of numbers. It first checks if k exceeds the length of the list, in which case it returns the entire list sorted in descending order. A min-heap is utilized to efficiently track the largest k elements as the function iterates through the list. If the heap contains fewer than k elements, it adds the current number; otherwise, it replaces the smallest element in the heap if the current number is larger. Finally, it returns the k largest elements sorted in descending order. This approach ensures optimal performance even with large datasets.\n\n[end of description]\n"
    },
    "find_duplicates": {
        "code": "from collections import Counter\n\ndef find_duplicates(int_list):\n    counts = Counter(int_list)\n    duplicates = [num for (num, count) in counts.items() if (count > 1)]\n    duplicates.sort()\n    return duplicates\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of all integers that appear more than once in the list. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: find_duplicates]\nThis function takes a list of integers as input and identifies the numbers that appear more than once. It utilizes the Counter class from the collections module to count the occurrences of each integer in the list. The function then creates a list of those integers that have a count greater than one, indicating they are duplicates. After identifying the duplicates, it sorts them in ascending order. Finally, the sorted list of duplicate integers is returned.\n\n[end of description]\n"
    },
    "quicksort": {
        "code": "\n\ndef quicksort(arr):\n    if (len(arr) <= 1):\n        return arr\n    else:\n        pivot = arr[(len(arr) // 2)]\n        left = [x for x in arr if (x < pivot)]\n        middle = [x for x in arr if (x == pivot)]\n        right = [x for x in arr if (x > pivot)]\n        return ((quicksort(left) + middle) + quicksort(right))\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the list sorted in ascending order using the quicksort algorithm. This will help you practice implementing a classic sorting algorithm and understanding its recursive nature.",
        "description": "\n[description for function: quicksort]\nThis function implements the quicksort algorithm to sort an array. It first checks if the array has one or no elements, in which case it returns the array as is. If the array has more than one element, it selects a pivot element and partitions the array into three sub-arrays: those less than the pivot, those equal to the pivot, and those greater than the pivot. It then recursively sorts the left and right sub-arrays. Finally, it combines the sorted left sub-array, the middle sub-array, and the sorted right sub-array to produce the final sorted array. The function effectively sorts the input array in ascending order.\n\n[end of description]\n"
    },
    "is_palindrome": {
        "code": "import re\n\ndef is_palindrome(s):\n    cleaned = re.sub('[^a-zA-Z0-9]', '', s).lower()\n    return (cleaned == cleaned[::(- 1)])\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns True if the string is a palindrome (reads the same forwards and backwards), ignoring spaces, punctuation, and capitalization. Otherwise, return False.",
        "description": "\n[description for function: is_palindrome]\nThis function checks if a given string is a palindrome, which means it reads the same forwards and backwards. It first removes any non-alphanumeric characters and converts the string to lowercase for uniformity. After cleaning the string, it compares the cleaned version to its reverse. If both are identical, it returns True, indicating that the string is a palindrome; otherwise, it returns False. The function effectively handles various input formats by focusing solely on the alphanumeric content. Overall, it provides a straightforward way to determine palindrome status for any input string.\n\n[end of description]\n"
    },
    "unique_elements": {
        "code": "from collections import Counter\n\ndef unique_elements(input_list):\n    counts = Counter(input_list)\n    unique_integers = [num for (num, count) in counts.items() if (count == 1)]\n    unique_integers.sort()\n    return unique_integers\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of integers that appear only once in the original list. The result should be sorted in ascending order.",
        "description": "\n[description for function: unique_elements]\nThis function takes a list as input and counts the occurrences of each element using the Counter class. It then creates a new list containing only the elements that appear exactly once in the input list. After filtering, the unique elements are sorted in ascending order. Finally, the function returns the sorted list of unique integers.\n\n[end of description]\n"
    },
    "find_substrings": {
        "code": "\n\ndef find_substrings(input_string, word_list):\n    result = []\n    for word in word_list:\n        if (word in input_string):\n            result.append(word)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and a list of words, and returns a list of words from the list that are substrings of the given string. This will help practice string manipulation and searching techniques.",
        "description": "\n[description for function: find_substrings]\nThis function takes an input string and a list of words, then checks each word to see if it is present in the input string. If a word is found within the input string, it is added to a result list. After checking all the words, the function returns the list of found words. The function effectively filters the word list based on their presence in the input string. It is useful for identifying specific substrings from a larger text. The output is a list containing all the words that were found.\n\n[end of description]\n"
    },
    "find_duplicates_v2": {
        "code": "from collections import Counter\n\ndef find_duplicates_v2(input_list):\n    counts = Counter(input_list)\n    duplicates = {num for (num, count) in counts.items() if (count > 1)}\n    return sorted(duplicates)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of integers that appear more than once in the list. The result should not contain duplicates and should be sorted in ascending order.",
        "description": "\n[description for function: find_duplicates]\nThis function takes a list as input and identifies the elements that appear more than once. It utilizes the Counter class from the collections module to count the occurrences of each element in the list. The function then creates a set of elements that have a count greater than one, indicating they are duplicates. Finally, it returns a sorted list of these duplicate elements. The output is a list containing only the unique duplicates, arranged in ascending order. This allows for easy identification of repeated items in the original list.\n\n[end of description]\n"
    },
    "find_duplicates_v3": {
        "code": "\n\ndef find_duplicates_v3(input_list):\n    seen = set()\n    duplicates = set()\n    for number in input_list:\n        if (number in seen):\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    return sorted(duplicates)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a list of integers that are duplicates in the original list. The result should not contain duplicates and should be sorted in ascending order. Use a set to efficiently find duplicates.",
        "description": "\n[description for function: find_duplicates]\nThis function takes a list of numbers as input and identifies any duplicate values within that list. It utilizes a set to keep track of numbers that have already been encountered and another set to store duplicates. As it iterates through the input list, it checks if each number has been seen before; if so, it adds it to the duplicates set. Finally, the function returns a sorted list of the duplicate numbers found. The use of sets ensures that each duplicate is only recorded once, regardless of how many times it appears in the input list. Overall, it efficiently identifies and returns the duplicates in a sorted order.\n\n[end of description]\n"
    },
    "is_valid_parentheses": {
        "code": "\n\ndef is_valid_parentheses(s: str) -> bool:\n    stack = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if (char in bracket_map.values()):\n            stack.append(char)\n        elif (char in bracket_map.keys()):\n            if ((not stack) or (stack.pop() != bracket_map[char])):\n                return False\n    return (not stack)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string containing only the characters '(', ')', '{', '}', '[' and ']', and returns True if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. The function should return False otherwise.",
        "description": "\n[description for function: is_valid_parentheses]\nThis function checks if a given string of parentheses is valid by using a stack to track opening brackets and ensuring that each closing bracket corresponds to the most recent unmatched opening bracket. It iterates through each character in the string, pushing opening brackets onto the stack and popping from the stack when a closing bracket is encountered. If a closing bracket does not match the expected opening bracket or if there are unmatched opening brackets left in the stack at the end, the function returns False. If all brackets are matched correctly, it returns True. The function effectively handles different types of brackets, including parentheses, curly braces, and square brackets. Overall, it ensures that the brackets are properly nested and closed.\n\n[end of description]\n"
    },
    "evaluate_postfix": {
        "code": "\n\ndef evaluate_postfix(expression):\n    stack = []\n    for token in expression:\n        if token.isdigit():\n            stack.append(int(token))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            if (token == '+'):\n                result = (a + b)\n            elif (token == '-'):\n                result = (a - b)\n            elif (token == '*'):\n                result = (a * b)\n            elif (token == '/'):\n                result = int((a / b))\n            stack.append(result)\n    return stack.pop()\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings representing a postfix expression (Reverse Polish Notation) and returns the evaluated result as an integer. The function should use a stack to evaluate the expression.",
        "description": "\n[description for function: evaluate_postfix]\nThis function evaluates a postfix expression represented as a list of tokens. It uses a stack to store operands and processes each token in the expression sequentially. When a digit is encountered, it is pushed onto the stack, while operators trigger the popping of the top two operands for computation. The result of the operation is then pushed back onto the stack. At the end of the evaluation, the final result is returned from the stack. This allows for the calculation of expressions in postfix notation efficiently.\n\n[end of description]\n"
    },
    "second_largest_unique": {
        "code": "\n\ndef second_largest_unique(nums):\n    unique_nums = set(nums)\n    if (len(unique_nums) < 2):\n        return None\n    sorted_unique_nums = sorted(unique_nums, reverse=True)\n    return sorted_unique_nums[1]\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the second largest unique integer in the list. If there is no such integer, return None. This task will help you practice using sets for unique elements and sorting techniques.",
        "description": "\n[description for function: second_largest_unique]\nThis function takes a list of numbers as input and identifies the second largest unique number from that list. It first converts the list into a set to eliminate any duplicates. If there are fewer than two unique numbers, it returns None. The unique numbers are then sorted in descending order. Finally, the function returns the second element from this sorted list, which corresponds to the second largest unique number.\n\n[end of description]\n"
    },
    "index_tracker": {
        "code": "\n\ndef index_tracker(int_list):\n    index_dict = {}\n    for (index, value) in enumerate(int_list):\n        if (value not in index_dict):\n            index_dict[value] = []\n        index_dict[value].append(index)\n    return index_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a dictionary where the keys are the integers and the values are lists of indices where each integer appears in the list. This will help practice using dictionaries to store lists and track multiple occurrences of elements.",
        "description": "\n[description for function: index_tracker]\nThis function takes a list of integers as input and creates a dictionary that maps each unique integer to a list of its indices in the original list. It iterates through the list while keeping track of both the index and the value of each element. If a value is encountered for the first time, it initializes an empty list for that value in the dictionary. The current index is then appended to the list corresponding to that value. Finally, the function returns the dictionary containing the integer-to-index mappings. This allows for easy retrieval of all positions of each integer in the input list.\n\n[end of description]\n"
    },
    "first_unique_character": {
        "code": "\n\ndef first_unique_character(s):\n    char_count = {}\n    for char in s:\n        if (char in char_count):\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if (char_count[char] == 1):\n            return char\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the first unique character in it. Use a dictionary to count the occurrences of each character. If there is no unique character, return None.",
        "description": "\n[description for function: first_unique_character]\nThis function takes a string as input and counts the occurrences of each character in it. It uses a dictionary to store the count of each character. After counting, it iterates through the string again to find the first character that appears only once. If such a character is found, it is returned; otherwise, the function returns None. The function effectively identifies the first unique character in the given string.\n\n[end of description]\n"
    },
    "sum_of_tree": {
        "code": "\n\ndef sum_of_tree(tree):\n    if (not tree):\n        return 0\n    current_value = tree[0]\n    left_sum = (sum_of_tree(tree[1]) if (len(tree) > 1) else 0)\n    right_sum = (sum_of_tree(tree[2]) if (len(tree) > 2) else 0)\n    return ((current_value + left_sum) + right_sum)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a binary tree (represented as a nested list) and returns the sum of all its nodes. The binary tree is represented as a list where the first element is the root value, the second element is the left subtree, and the third element is the right subtree. If a subtree is empty, it is represented as an empty list.",
        "description": "\n[description for function: sum_of_tree]\nThis function calculates the sum of all values in a binary tree represented as a nested list, where the first element is the root value, the second element is the left subtree, and the third element is the right subtree. It first checks if the tree is empty, returning 0 if so. Then, it retrieves the current node's value and recursively computes the sums of the left and right subtrees. Finally, it returns the total sum by adding the current value to the sums of the left and right subtrees. The function effectively traverses the tree in a depth-first manner to accumulate the total sum.\n\n[end of description]\n"
    },
    "bfs_traversal": {
        "code": "from collections import deque\n\ndef bfs_traversal(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    order_of_visit = []\n    while queue:\n        current_node = queue.popleft()\n        order_of_visit.append(current_node)\n        for neighbor in graph[current_node]:\n            if (neighbor not in visited):\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return order_of_visit\n",
        "dependencies": [],
        "task": "Write a Python function that performs a breadth-first search (BFS) on a graph represented as an adjacency list. The function should take the graph and a starting node as inputs and return a list of nodes in the order they are visited.",
        "description": "\n[description for function: bfs_traversal]\nThis function performs a breadth-first search (BFS) traversal on a given graph starting from a specified node, returning the order in which nodes are visited. It initializes a set to keep track of visited nodes and a queue to manage the nodes to be explored. As it processes each node, it adds unvisited neighbors to the queue and marks them as visited. The traversal continues until all reachable nodes have been explored. Finally, it returns a list representing the sequence of nodes visited during the traversal. This approach ensures that nodes are explored level by level.\n\n[end of description]\n"
    },
    "find_pattern_index": {
        "code": "\n\ndef find_pattern_index(main_string, pattern):\n    main_length = len(main_string)\n    pattern_length = len(pattern)\n    if (pattern_length == 0):\n        return 0\n    for i in range(((main_length - pattern_length) + 1)):\n        if (main_string[i:(i + pattern_length)] == pattern):\n            return i\n    return (- 1)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and a pattern (both strings) and returns the starting index of the first occurrence of the pattern in the string. If the pattern is not found, return -1. This will help practice string manipulation and searching techniques.",
        "description": "\n[description for function: find_pattern_index]\nThis function searches for the first occurrence of a specified pattern within a given main string. It calculates the lengths of both the main string and the pattern, returning 0 if the pattern is empty. The function iterates through the main string, checking each substring of the same length as the pattern for a match. If a match is found, it returns the starting index of the pattern within the main string. If no match is found after checking all possible positions, it returns -1. This effectively allows for a straightforward substring search.\n\n[end of description]\n"
    },
    "sum_of_evens": {
        "code": "\n\ndef sum_of_evens(numbers):\n    total = 0\n    for number in numbers:\n        if ((number % 2) == 0):\n            total += number\n    return total\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of all even numbers in the list. This task will help practice iterating through lists and applying conditional logic.",
        "description": "\n[description for function: sum_of_evens]\nThis function takes a list of numbers as input and calculates the sum of all even numbers within that list. It initializes a total variable to zero and iterates through each number in the input list. For each number, it checks if the number is even by using the modulus operator. If the number is even, it adds it to the total. Finally, the function returns the computed total of even numbers. The result is the sum of all even integers found in the provided list.\n\n[end of description]\n"
    },
    "find_perfect_squares": {
        "code": "\n\ndef find_perfect_squares(n):\n    squares = []\n    i = 1\n    while True:\n        square = (i * i)\n        if (square < n):\n            squares.append(square)\n        else:\n            break\n        i += 1\n    return squares\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns a list of all perfect squares less than n. A perfect square is an integer that is the square of an integer. This task will help practice loops, conditionals, and understanding of number properties.",
        "description": "\n[description for function: find_perfect_squares]\nThis function generates a list of perfect squares that are less than a given integer n. It initializes an empty list to store the squares and uses a loop to calculate the square of consecutive integers starting from 1. If the calculated square is less than n, it adds the square to the list; otherwise, it breaks the loop. The process continues until the square exceeds or equals n. Finally, it returns the list of perfect squares found.\n\n[end of description]\n"
    }
}