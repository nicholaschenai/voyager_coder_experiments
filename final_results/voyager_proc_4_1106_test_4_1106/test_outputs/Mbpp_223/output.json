{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n\nTests failed:\nNone",
    "state": null,
    "code": "\n\ndef is_majority(arr, n, element):\n\n    def find_first(arr, element):\n        (low, high) = (0, (len(arr) - 1))\n        while (low <= high):\n            mid = ((low + high) // 2)\n            if (arr[mid] < element):\n                low = (mid + 1)\n            elif ((arr[mid] > element) or ((mid > 0) and (arr[(mid - 1)] == element))):\n                high = (mid - 1)\n            else:\n                return mid\n        return (- 1)\n\n    def find_last(arr, element):\n        (low, high) = (0, (len(arr) - 1))\n        while (low <= high):\n            mid = ((low + high) // 2)\n            if (arr[mid] > element):\n                high = (mid - 1)\n            elif ((arr[mid] < element) or ((mid < (len(arr) - 1)) and (arr[(mid + 1)] == element))):\n                low = (mid + 1)\n            else:\n                return mid\n        return (- 1)\n    if (element not in arr):\n        return False\n    first_index = find_first(arr, element)\n    last_index = find_last(arr, element)\n    count = ((last_index - first_index) + 1)\n    return (count > (n / 2))\n",
    "full_code": "\n\ndef is_majority(arr, n, element):\n\n    def find_first(arr, element):\n        (low, high) = (0, (len(arr) - 1))\n        while (low <= high):\n            mid = ((low + high) // 2)\n            if (arr[mid] < element):\n                low = (mid + 1)\n            elif ((arr[mid] > element) or ((mid > 0) and (arr[(mid - 1)] == element))):\n                high = (mid - 1)\n            else:\n                return mid\n        return (- 1)\n\n    def find_last(arr, element):\n        (low, high) = (0, (len(arr) - 1))\n        while (low <= high):\n            mid = ((low + high) // 2)\n            if (arr[mid] > element):\n                high = (mid - 1)\n            elif ((arr[mid] < element) or ((mid < (len(arr) - 1)) and (arr[(mid + 1)] == element))):\n                low = (mid + 1)\n            else:\n                return mid\n        return (- 1)\n    if (element not in arr):\n        return False\n    first_index = find_first(arr, element)\n    last_index = find_last(arr, element)\n    count = ((last_index - first_index) + 1)\n    return (count > (n / 2))\n",
    "task_id": "Mbpp/223",
    "success": true,
    "critique": "",
    "reasoning": ""
}