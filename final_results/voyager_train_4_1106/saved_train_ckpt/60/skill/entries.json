{
    "square_list": {
        "code": "\n\ndef square_list(input_list):\n    squared_list = []\n    for number in input_list:\n        squared_list.append((number * number))\n    return squared_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the squares of all the numbers. The function should not modify the original list.",
        "description": "\n[description for function: square_list]\nThis function takes a list of numbers as input and creates a new list containing the squares of each number from the input list. It initializes an empty list to store the squared values. Then, it iterates through each number in the input list, calculates its square, and appends the result to the new list. Finally, the function returns the list of squared numbers. The output list will have the same length as the input list, with each element being the square of the corresponding input element. This function effectively transforms the input list by applying a mathematical operation to each of its elements.\n\n[end of description]\n"
    },
    "unique_elements": {
        "code": "\n\ndef unique_elements(input_list):\n    unique_set = set(input_list)\n    unique_list = list(unique_set)\n    return unique_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list containing only the unique elements from the original list. The order of elements in the returned list does not matter.",
        "description": "\n[description for function: unique_elements]\nThis function takes a list as input and converts it into a set to eliminate any duplicate elements. It then transforms the set back into a list, resulting in a collection of unique elements. The order of elements may not be preserved since sets do not maintain order. Finally, the function returns this list of unique elements. This is useful for situations where only distinct values are needed from a given list. Overall, it provides a simple way to filter out duplicates from a list.\n\n[end of description]\n"
    },
    "find_duplicates": {
        "code": "from collections import Counter\n\ndef find_duplicates(int_list):\n    counts = Counter(int_list)\n    duplicates = {num for (num, count) in counts.items() if (count > 1)}\n    return duplicates\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a set containing all the elements that appear more than once in the list.",
        "description": "\n[description for function: find_duplicates]\nThis function takes a list of integers as input and counts the occurrences of each integer using the Counter class from the collections module. It then creates a set of integers that appear more than once in the list, identifying them as duplicates. Finally, the function returns this set of duplicate integers. The use of a set ensures that each duplicate is listed only once, regardless of how many times it appears in the input list. The function efficiently handles the counting and filtering in a concise manner. Overall, it provides a straightforward way to identify duplicate values in a list of integers.\n\n[end of description]\n"
    },
    "calculate_factorial": {
        "code": "\n\ndef calculate_factorial(n):\n    if (n < 0):\n        raise ValueError('Factorial is not defined for negative numbers.')\n    if (n == 0):\n        return 1\n    result = 1\n    for i in range(1, (n + 1)):\n        result *= i\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that calculates the factorial of a given non-negative integer. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. It is denoted by n!.",
        "description": "\n[description for function: calculate_factorial]\nThis function computes the factorial of a non-negative integer n. It raises a ValueError if n is negative, as factorials are not defined for such values. For n equal to zero, it returns 1, since 0! is defined as 1. For positive integers, it initializes a result variable to 1 and iteratively multiplies it by each integer from 1 to n. Finally, it returns the computed factorial value. The function effectively handles edge cases and performs the calculation using a simple loop.\n\n[end of description]\n"
    },
    "is_palindrome": {
        "code": "\n\ndef is_palindrome(s):\n    normalized_str = s.lower()\n    filtered_str = ''.join((char for char in normalized_str if char.isalnum()))\n    return (filtered_str == filtered_str[::(- 1)])\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns True if the string is a palindrome, and False otherwise. The function should be case-insensitive and ignore all non-alphanumeric characters.",
        "description": "\n[description for function: is_palindrome]\nThis function checks if a given string is a palindrome, which means it reads the same forwards and backwards. It first normalizes the string by converting it to lowercase and filtering out non-alphanumeric characters. Then, it compares the filtered string to its reverse. If both are identical, it returns True, indicating that the string is a palindrome; otherwise, it returns False. The function effectively ignores case and punctuation, focusing solely on the alphanumeric content. This makes it suitable for checking phrases and sentences as well as single words.\n\n[end of description]\n"
    },
    "get_dict_value": {
        "code": "\n\ndef get_dict_value(dictionary, key):\n    if (key in dictionary):\n        return dictionary[key]\n    else:\n        return 'Key not found.'\n",
        "dependencies": [],
        "task": "Write a Python function that takes a dictionary and a key, and returns the value associated with the key. If the key does not exist in the dictionary, the function should return 'Key not found.'",
        "description": "\n[description for function: get_dict_value]\nThis function retrieves the value associated with a specified key from a given dictionary. If the key exists in the dictionary, it returns the corresponding value. If the key is not found, it returns a message indicating that the key is not present. The function effectively handles both scenarios of key existence. It provides a straightforward way to access dictionary values while also managing potential errors. Overall, it enhances the usability of dictionary lookups in Python.\n\n[end of description]\n"
    },
    "first_recurring_character": {
        "code": "\n\ndef first_recurring_character(int_list):\n    seen = set()\n    for num in int_list:\n        if (num in seen):\n            return num\n        seen.add(num)\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the first recurring character. If there is no recurring character, return None.",
        "description": "\n[description for function: first_recurring_character]\nThis function takes a list of integers as input and identifies the first recurring character within that list. It utilizes a set to keep track of the numbers that have already been encountered. As it iterates through the list, it checks if the current number has been seen before; if so, it returns that number as the first recurring character. If no recurring number is found by the end of the list, it returns None. The function effectively provides a quick way to find duplicates in a single pass through the list. Overall, it is efficient and straightforward in its approach to solving the problem.\n\n[end of description]\n"
    },
    "bubble_sort": {
        "code": "\n\ndef bubble_sort(input_list):\n    n = len(input_list)\n    for i in range((n - 1)):\n        for j in range(((n - 1) - i)):\n            if (input_list[j] > input_list[(j + 1)]):\n                (input_list[j], input_list[(j + 1)]) = (input_list[(j + 1)], input_list[j])\n    return input_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the integers sorted in ascending order using the bubble sort algorithm.",
        "description": "\n[description for function: bubble_sort]\nThis function implements the bubble sort algorithm to sort a given list in ascending order by repeatedly comparing adjacent elements and swapping them if they are in the wrong order, effectively \"bubbling\" larger elements to the end of the list. It iterates through the list multiple times, reducing the number of comparisons in each subsequent pass as the largest elements settle at the end. The process continues until the entire list is sorted. The function returns the sorted list after completing the sorting process. It operates with a time complexity of O(n^2) in the worst case, making it less efficient for large datasets. Overall, it provides a straightforward method for sorting a list using a simple comparison-based approach.\n\n[end of description]\n"
    },
    "first_non_repeating_character": {
        "code": "\n\ndef first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if (char in char_count):\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if (char_count[char] == 1):\n            return char\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the first non-repeating character in it. If all characters repeat or the string is empty, return None.",
        "description": "\n[description for function: first_non_repeating_character]\nThis function takes a string as input and counts the occurrences of each character in it. It uses a dictionary to store the count of each character. After counting, it iterates through the string again to find the first character that appears only once. If such a character is found, it is returned; otherwise, the function returns None. This effectively identifies the first non-repeating character in the input string. The function handles both empty strings and strings with all repeating characters gracefully.\n\n[end of description]\n"
    },
    "simulate_producer_consumer": {
        "code": "\n\ndef simulate_producer_consumer(items):\n    queue = []\n    consumed_count = 0\n    for item in items:\n        queue.append(item)\n    while queue:\n        item = queue.pop(0)\n        print(item)\n        consumed_count += 1\n    return consumed_count\n",
        "dependencies": [],
        "task": "Write a Python function that simulates a producer-consumer scenario using a queue. The function should take a list of integers as input, where each integer represents an item produced. The function should process (consume) each item by simply printing it and then return the number of items consumed. Use a simple list to simulate the queue behavior.",
        "description": "\n[description for function: simulate_producer_consumer]\nThis function simulates a producer-consumer scenario by taking a list of items as input and adding them to a queue. It then processes each item in the queue by removing it from the front and printing it. The function keeps track of the number of items consumed during this process. Once all items have been processed, it returns the total count of consumed items. The function effectively demonstrates a simple queue operation where items are produced and consumed sequentially.\n\n[end of description]\n"
    },
    "fibonacci": {
        "code": "\n\ndef fibonacci(n):\n    if (n == 0):\n        return 0\n    elif (n == 1):\n        return 1\n    else:\n        return (fibonacci((n - 1)) + fibonacci((n - 2)))\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns the nth Fibonacci number. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The function should use recursion to calculate the result.",
        "description": "\n[description for function: fibonacci]\nThis function calculates the nth Fibonacci number using a recursive approach. It returns 0 if the input is 0 and 1 if the input is 1. For any other positive integer, it computes the Fibonacci number by summing the two preceding Fibonacci numbers. The function continues to call itself until it reaches the base cases. This results in a straightforward but inefficient implementation due to repeated calculations. Overall, it provides a clear demonstration of recursion in generating Fibonacci numbers.\n\n[end of description]\n"
    },
    "length_of_longest_substring": {
        "code": "\n\ndef length_of_longest_substring(s: str) -> int:\n    char_set = set()\n    max_length = 0\n    start = 0\n    for end in range(len(s)):\n        while (s[end] in char_set):\n            char_set.remove(s[start])\n            start += 1\n        char_set.add(s[end])\n        max_length = max(max_length, ((end - start) + 1))\n    return max_length\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the length of the longest substring without repeating characters.",
        "description": "\n[description for function: length_of_longest_substring]\nThis function calculates the length of the longest substring without repeating characters in a given string. It uses a sliding window approach, maintaining a set of characters currently in the substring. As it iterates through the string, it expands the end of the window and adjusts the start when a duplicate character is found. The maximum length of valid substrings is updated throughout the process. Finally, it returns the length of the longest substring identified. The function efficiently handles the input string in linear time.\n\n[end of description]\n"
    },
    "sort_strings_by_vowel_count": {
        "code": "\n\ndef sort_strings_by_vowel_count(strings):\n\n    def count_vowels(s):\n        return sum((1 for char in s.lower() if (char in 'aeiou')))\n    sorted_strings = sorted(strings, key=(lambda s: ((- count_vowels(s)), s)))\n    return sorted_strings\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a new list with the strings sorted based on the number of vowels they contain. The sort should be in descending order, and in case of a tie, the strings should be sorted alphabetically.",
        "description": "\n[description for function: sort_strings_by_vowel_count]\nThis function takes a list of strings and sorts them based on the number of vowels they contain, prioritizing strings with more vowels. In case of a tie in vowel counts, it sorts the strings alphabetically. The sorting is done in descending order of vowel count, meaning strings with the highest number of vowels appear first. The function converts each string to lowercase to ensure that the vowel count is case-insensitive. Finally, it returns the sorted list of strings.\n\n[end of description]\n"
    },
    "most_frequent_char": {
        "code": "\n\ndef most_frequent_char(s):\n    if (not s):\n        return None\n    frequency = {}\n    for char in s:\n        if (char in frequency):\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    max_char = None\n    max_count = 0\n    for char in s:\n        if (frequency[char] > max_count):\n            max_count = frequency[char]\n            max_char = char\n    return max_char\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the character that appears the most frequently in the string. If there is a tie, return the character that appears first in the string. If the string is empty, return None.",
        "description": "\n[description for function: most_frequent_char]\nThis function takes a string as input and returns the character that appears most frequently within that string. If the input string is empty, it returns None. It first counts the occurrences of each character using a dictionary to store the frequency. Then, it iterates through the string again to determine which character has the highest count. Finally, it returns the character with the maximum frequency. If there are multiple characters with the same maximum frequency, it returns the first one encountered.\n\n[end of description]\n"
    },
    "calculate_expression": {
        "code": "\n\ndef calculate_expression(expression):\n    numbers = expression.split('+')\n    integers = map(int, numbers)\n    return sum(integers)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string representing a mathematical expression consisting of non-negative integers and the plus sign (+) and returns the result of the expression. The function should assume that the input is always a valid expression and that there are no spaces between numbers and operators.",
        "description": "\n[description for function: calculate_expression]\nThis function takes a string representing a mathematical expression consisting of numbers separated by plus signs. It splits the string into individual number components and converts them from strings to integers. After converting, it calculates the sum of these integers. Finally, it returns the total sum as the output. The function effectively handles simple addition operations represented in string format. It assumes that the input expression is well-formed and contains only valid integers.\n\n[end of description]\n"
    },
    "recursive_sum": {
        "code": "\n\ndef recursive_sum(n):\n    if (n == 0):\n        return 0\n    else:\n        return (n + recursive_sum((n - 1)))\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns the sum of all integers from 1 to n using recursion.",
        "description": "\n[description for function: recursive_sum]\nThis function calculates the sum of all integers from 1 to a given non-negative integer n using recursion. It checks if n is zero, in which case it returns 0, indicating the base case of the recursion. If n is not zero, it adds n to the result of the function called with n decremented by 1. This process continues until n reaches zero, at which point the accumulated sum is returned. The function effectively computes the sum by breaking the problem down into smaller subproblems. It demonstrates a classic example of using recursion to solve a mathematical summation problem.\n\n[end of description]\n"
    },
    "selection_sort": {
        "code": "\n\ndef selection_sort(arr):\n    for i in range(len(arr)):\n        min_index = i\n        for j in range((i + 1), len(arr)):\n            if (arr[j] < arr[min_index]):\n                min_index = j\n        (arr[i], arr[min_index]) = (arr[min_index], arr[i])\n    return arr\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the integers sorted in ascending order using the selection sort algorithm.",
        "description": "\n[description for function: selection_sort]\nThis function sorts an array in ascending order using the selection sort algorithm. It iterates through each element of the array, identifying the smallest element in the unsorted portion. Once the smallest element is found, it swaps it with the current element being considered. This process continues until the entire array is sorted. The function modifies the original array and returns the sorted version. The time complexity of this sorting method is O(n^2).\n\n[end of description]\n"
    },
    "is_valid_parentheses": {
        "code": "\n\ndef is_valid_parentheses(s: str) -> bool:\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack = []\n    for char in s:\n        if (char in bracket_map.values()):\n            stack.append(char)\n        elif (char in bracket_map):\n            if ((not stack) or (stack[(- 1)] != bracket_map[char])):\n                return False\n            stack.pop()\n    return (not stack)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string containing only '(', ')', '{', '}', '[' and ']', and determines if the input string is valid. A string is considered valid if brackets are closed in the correct order. For example, \"()\" and \"()[]{}\" are valid, but \"(]\" and \"([)]\" are not.",
        "description": "\n[description for function: is_valid_parentheses]\nThis function checks if a string of parentheses is valid by using a stack to track opening brackets and ensuring that each closing bracket corresponds to the most recent unmatched opening bracket. It iterates through each character in the string, pushing opening brackets onto the stack and popping them when a matching closing bracket is found. If a closing bracket does not match the expected opening bracket or if there are unmatched opening brackets left in the stack at the end, the function returns false. If all brackets are matched correctly, it returns true. The function effectively handles different types of brackets, including parentheses, curly braces, and square brackets. Overall, it ensures that the brackets are properly nested and closed.\n\n[end of description]\n"
    },
    "last_person_served": {
        "code": "from collections import deque\n\ndef last_person_served(ticket_numbers):\n    queue = deque(ticket_numbers)\n    while (len(queue) > 1):\n        queue.popleft()\n    return queue[0]\n",
        "dependencies": [],
        "task": "Write a Python function that simulates a basic queue system. The function should take a list of integers representing people's ticket numbers and return the ticket number of the person who will be served last. Use the deque from the collections module to implement the queue.",
        "description": "\n[description for function: last_person_served]\nThe function processes a list of ticket numbers using a queue structure to simulate a serving line. It repeatedly removes the first ticket number until only one remains in the queue. The final ticket number left in the queue is then returned as the result. This effectively identifies the last person who would be served based on the initial order of ticket numbers. The function utilizes a deque for efficient removal of elements from the front of the queue. Overall, it provides a straightforward solution to determine the last ticket holder in a serving scenario.\n\n[end of description]\n"
    },
    "find_common_elements": {
        "code": "\n\ndef find_common_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    common_elements_set = set1.intersection(set2)\n    common_elements_list = list(common_elements_set)\n    return common_elements_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a list containing the elements that are common to both lists without duplicates. The order of the elements in the returned list does not matter.",
        "description": "\n[description for function: find_common_elements]\nThis function takes two lists as input and converts them into sets to eliminate duplicates. It then finds the intersection of these two sets, which contains the elements that are common to both lists. The common elements are converted back into a list format. Finally, the function returns this list of common elements. This approach efficiently identifies shared items between the two input lists. The result is a list containing only the elements that appear in both original lists.\n\n[end of description]\n"
    },
    "find_kth_largest": {
        "code": "import heapq\n\ndef find_kth_largest(nums, k):\n    min_heap = []\n    for num in nums:\n        if (len(min_heap) < k):\n            heapq.heappush(min_heap, num)\n        elif (num > min_heap[0]):\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, num)\n    return heapq.heappop(min_heap)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the kth largest element in the list. The function should use a min-heap to efficiently find the kth largest element.",
        "description": "\n[description for function: find_kth_largest]\nThis function finds the k-th largest element in a list of numbers by maintaining a min-heap of size k. It iterates through each number in the input list, adding it to the heap if the heap has fewer than k elements. If the heap is full and the current number is larger than the smallest element in the heap, it replaces the smallest element with the current number. After processing all numbers, the smallest element in the heap, which represents the k-th largest element in the original list, is returned. The use of a min-heap ensures efficient retrieval of the k-th largest element. Overall, the function efficiently handles the problem with a time complexity of O(n log k).\n\n[end of description]\n"
    },
    "length_of_lis": {
        "code": "\n\ndef length_of_lis(nums):\n    if (not nums):\n        return 0\n    dp = ([1] * len(nums))\n    for i in range(len(nums)):\n        for j in range(i):\n            if (nums[j] < nums[i]):\n                dp[i] = max(dp[i], (dp[j] + 1))\n    return max(dp)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the length of the longest increasing subsequence in the list. The function should not modify the original list.",
        "description": "\n[description for function: length_of_lis]\nThis function calculates the length of the longest increasing subsequence in a given list of numbers. It initializes a dynamic programming array to keep track of the longest subsequence lengths at each index. The function iterates through the list, comparing each element with the previous ones to update the lengths based on the increasing condition. Finally, it returns the maximum value from the dynamic programming array, which represents the length of the longest increasing subsequence. If the input list is empty, it returns 0. Overall, it efficiently determines the desired length using a nested loop approach.\n\n[end of description]\n"
    },
    "is_balanced": {
        "code": "\n\ndef is_balanced(s: str) -> bool:\n    bracket_map = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for char in s:\n        if (char in bracket_map.values()):\n            stack.append(char)\n        elif (char in bracket_map):\n            if ((not stack) or (stack[(- 1)] != bracket_map[char])):\n                return False\n            stack.pop()\n    return (len(stack) == 0)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string containing only '(', ')', '[', ']', '{', and '}', and determines if the input string is balanced. A string is balanced if all types of brackets are properly closed and nested. The function should return True if the string is balanced, and False otherwise.",
        "description": "\n[description for function: is_balanced]\nThis function checks if a string containing various types of brackets is balanced. It uses a stack to keep track of opening brackets and matches them with their corresponding closing brackets. As it iterates through the string, it pushes opening brackets onto the stack and pops them when a matching closing bracket is found. If a closing bracket does not match the most recent opening bracket or if there are unmatched opening brackets left in the stack at the end, it returns false. If all brackets are matched correctly, it returns true. The function effectively ensures that every opening bracket has a corresponding and correctly ordered closing bracket.\n\n[end of description]\n"
    },
    "linear_search": {
        "code": "\n\ndef linear_search(int_list, target):\n    for (index, value) in enumerate(int_list):\n        if (value == target):\n            return index\n    return (- 1)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and a target integer. The function should return the index of the target integer in the list if it exists, or -1 if the target is not present.",
        "description": "\n[description for function: linear_search]\nThis function takes a list of integers and a target integer as inputs, and it searches for the target within the list. It iterates through the list, checking each element to see if it matches the target. If a match is found, it returns the index of the target element. If the target is not found after checking all elements, it returns -1. The function effectively implements a linear search algorithm. It is straightforward and operates with a time complexity of O(n).\n\n[end of description]\n"
    },
    "look_and_say": {
        "code": "\n\ndef look_and_say(n):\n    if (n == 0):\n        return '1'\n    current_term = '1'\n    for _ in range(1, n):\n        next_term = ''\n        count = 1\n        for j in range(1, len(current_term)):\n            if (current_term[j] == current_term[(j - 1)]):\n                count += 1\n            else:\n                next_term += (str(count) + current_term[(j - 1)])\n                count = 1\n        next_term += (str(count) + current_term[(- 1)])\n        current_term = next_term\n    return current_term\n",
        "dependencies": [],
        "task": "Write a Python function that takes a non-negative integer n and returns the nth number in the 'look-and-say' sequence. The 'look-and-say' sequence starts with '1' and each subsequent term is derived by describing the previous term. For example, the term after '1' is '11' (one 1), after '11' is '21' (two 1s), after '21' is '1211' (one 2, then one 1), and so on.",
        "description": "\n[description for function: look_and_say]\nThis function generates the nth term of the \"look-and-say\" sequence, starting from the first term, which is '1'. It iteratively constructs each subsequent term by counting consecutive digits in the current term and describing them as a count followed by the digit. If the input is zero, it returns '1' immediately. For each term, it initializes a count and builds the next term by checking each digit against the previous one. The process continues until the desired term is reached, and the final term is returned as a string. The function effectively transforms the sequence based on the counts of digits in each term.\n\n[end of description]\n"
    },
    "count_pairs_with_difference": {
        "code": "\n\ndef count_pairs_with_difference(nums):\n    unique_nums = set(nums)\n    count = 0\n    for num in unique_nums:\n        if ((num + 2) in unique_nums):\n            count += 1\n        if ((num - 2) in unique_nums):\n            count += 1\n    return (count // 2)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the number of distinct pairs of elements that have a difference of 2. The function should handle negative numbers as well.",
        "description": "\n[description for function: count_pairs_with_difference]\nThis function counts the number of unique pairs in a list of numbers that have a difference of exactly 2. It first converts the list into a set to eliminate duplicates and facilitate faster lookups. Then, for each unique number, it checks if either the number plus 2 or the number minus 2 exists in the set. For each valid pair found, it increments a count. Finally, it returns half of the count to account for the fact that each pair is counted twice. The result is the total number of unique pairs with the specified difference.\n\n[end of description]\n"
    },
    "count_characters": {
        "code": "\n\ndef count_characters(input_string):\n    char_count = {}\n    for char in input_string:\n        if (char in char_count):\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    return char_count\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns a dictionary where the keys are characters and the values are the number of times each character appears in the string.",
        "description": "\n[description for function: count_characters]\nThis function takes a string as input and counts the occurrences of each character within that string. It initializes an empty dictionary to store the character counts. As it iterates through each character in the input string, it updates the count for each character in the dictionary. If a character is already present in the dictionary, its count is incremented; otherwise, it is added with a count of one. Finally, the function returns the dictionary containing the character counts. This allows users to easily see how many times each character appears in the input string.\n\n[end of description]\n"
    },
    "sort_strings_by_length": {
        "code": "\n\ndef sort_strings_by_length(strings):\n    return sorted(strings, key=(lambda s: ((- len(s)), s)))\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a new list with the strings sorted in descending order based on their length. If two strings have the same length, they should be sorted alphabetically in ascending order.",
        "description": "\n[description for function: sort_strings_by_length]\nThis function takes a list of strings as input and sorts them primarily by their length in descending order. In cases where multiple strings have the same length, it sorts those strings alphabetically in ascending order. The sorting is achieved using the built-in `sorted` function with a custom key. The key is a tuple that consists of the negative length of the string and the string itself. This ensures that longer strings come first, and among strings of the same length, they are ordered lexicographically. The function returns the sorted list of strings.\n\n[end of description]\n"
    },
    "merge_sort": {
        "code": "\n\ndef merge(left, right):\n    sorted_list = []\n    i = j = 0\n    while ((i < len(left)) and (j < len(right))):\n        if (left[i] < right[j]):\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n    return sorted_list\n\n\n\n\ndef merge_sort(arr):\n    if (len(arr) <= 1):\n        return arr\n    mid = (len(arr) // 2)\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    sorted_left = merge_sort(left_half)\n    sorted_right = merge_sort(right_half)\n    return merge(sorted_left, sorted_right)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the integers sorted in ascending order using the merge sort algorithm. The function should not modify the original list.",
        "description": "\n[description for function: merge_sort]\nThis function sorts an array using the merge sort algorithm, which is a divide-and-conquer approach. It first checks if the array has one or fewer elements, in which case it is already sorted and returned. If the array has more elements, it splits the array into two halves and recursively sorts each half. After sorting both halves, it merges them back together in sorted order. The merging process involves comparing elements from both halves and combining them into a new sorted list. The final result is a fully sorted array.\n\n[end of description]\n"
    },
    "sum_of_two_largest": {
        "code": "\n\ndef sum_of_two_largest(numbers):\n    largest = find_kth_largest(numbers, 1)\n    second_largest = find_kth_largest(numbers, 2)\n    return (largest + second_largest)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of the two largest numbers in the list. The function should handle lists with at least two integers and should not modify the original list.",
        "description": "\n[description for function: sum_of_two_largest]\nThis function calculates the sum of the two largest numbers in a given list. It first identifies the largest number by finding the first largest element. Then, it determines the second largest number by finding the second largest element in the list. Finally, it returns the sum of these two largest numbers. The function effectively handles the task of extracting and summing the top two values from the input list. It assumes that the list contains at least two distinct numbers.\n\n[end of description]\n"
    },
    "first_duplicate": {
        "code": "\n\ndef first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if (num in seen):\n            return num\n        seen.add(num)\n    return (- 1)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the first duplicate number for which the second occurrence has the minimal index. If there are no duplicates, return -1.",
        "description": "\n[description for function: first_duplicate]\nThis function takes a list of integers as input and aims to find the first duplicate number in the list. It utilizes a set to keep track of the numbers that have already been encountered. As it iterates through the list, it checks if the current number is already in the set; if so, it returns that number as the first duplicate. If no duplicates are found by the end of the iteration, it returns -1. The function efficiently identifies duplicates with a time complexity of O(n) due to the use of a set for constant time lookups. Overall, it provides a straightforward solution to the problem of finding the first duplicate in a list.\n\n[end of description]\n"
    },
    "product_except_self": {
        "code": "\n\ndef product_except_self(nums):\n    n = len(nums)\n    left_products = ([1] * n)\n    right_products = ([1] * n)\n    result = ([0] * n)\n    for i in range(1, n):\n        left_products[i] = (left_products[(i - 1)] * nums[(i - 1)])\n    for i in range((n - 2), (- 1), (- 1)):\n        right_products[i] = (right_products[(i + 1)] * nums[(i + 1)])\n    for i in range(n):\n        result[i] = (left_products[i] * right_products[i])\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the product of all the elements in the list except for the current index. For each index, you should find the product of all the integers except the integer at that index, without using division. The function should return a new list with the products.",
        "description": "\n[description for function: product_except_self]\nThis function calculates the product of all elements in an input list except for the element at the current index, without using division. It initializes two lists to store the cumulative products from the left and right sides of each index. The function iterates through the input list to fill these left and right product lists. Finally, it multiplies the corresponding values from the left and right lists to produce the final result. The output is a new list where each element represents the product of all other elements in the input list. This approach ensures that the solution runs in linear time and uses constant space for the output.\n\n[end of description]\n"
    },
    "most_frequent_integer": {
        "code": "\n\ndef most_frequent_integer(int_list):\n    if (not int_list):\n        return None\n    frequency = {}\n    for num in int_list:\n        frequency[num] = (frequency.get(num, 0) + 1)\n    max_count = 0\n    most_frequent = None\n    for (num, count) in frequency.items():\n        if ((count > max_count) or ((count == max_count) and ((most_frequent is None) or (num < most_frequent)))):\n            max_count = count\n            most_frequent = num\n    return most_frequent\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the most frequent integer in the list. If there is a tie, return the smallest integer among the most frequent ones. If the list is empty, return None.",
        "description": "\n[description for function: most_frequent_integer]\nThis function takes a list of integers as input and returns the most frequently occurring integer in that list. If the list is empty, it returns None. It counts the occurrences of each integer using a dictionary to track their frequencies. After counting, it determines which integer has the highest frequency, and in case of a tie, it selects the smallest integer. Finally, it returns the integer that is most frequent.\n\n[end of description]\n"
    },
    "insertion_sort": {
        "code": "\n\ndef insertion_sort(original_list):\n    sorted_list = []\n    for number in original_list:\n        index = 0\n        while ((index < len(sorted_list)) and (sorted_list[index] < number)):\n            index += 1\n        sorted_list.insert(index, number)\n    return sorted_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the integers sorted in ascending order using the insertion sort algorithm. The function should not modify the original list.",
        "description": "\n[description for function: insertion_sort]\nThis function takes a list of numbers as input and sorts it using the insertion sort algorithm. It initializes an empty list to hold the sorted elements. For each number in the original list, it finds the appropriate index in the sorted list where the number should be inserted. The number is then inserted at that index, maintaining the order of the sorted list. Finally, the function returns the newly sorted list. This approach ensures that the list is built up in a sorted manner as each element is processed.\n\n[end of description]\n"
    },
    "is_balanced_v2": {
        "code": "\n\ndef is_balanced_v2(s: str) -> bool:\n    stack = []\n    bracket_map = {')': '(', ']': '[', '}': '{'}\n    for char in s:\n        if (char in bracket_map.values()):\n            stack.append(char)\n        elif (char in bracket_map):\n            if ((not stack) or (stack[(- 1)] != bracket_map[char])):\n                return False\n            stack.pop()\n    return (not stack)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string containing only '(', ')', '[', ']', '{', and '}', and determines if the input string has balanced parentheses, brackets, and braces. A string is balanced if all types of brackets are correctly closed and nested. The function should return True if the string is balanced, and False otherwise.",
        "description": "\n[description for function: is_balanced]\nThis function checks if a string containing various types of brackets (parentheses, square brackets, and curly braces) is balanced, meaning that every opening bracket has a corresponding closing bracket in the correct order. It uses a stack to keep track of the opening brackets encountered as it iterates through the string. When a closing bracket is found, it checks if it matches the most recent opening bracket on the stack. If there is a mismatch or if a closing bracket appears without a corresponding opening bracket, the function returns False. At the end of the iteration, if the stack is empty, it indicates that all brackets were properly closed, and the function returns True; otherwise, it returns False. This ensures that the brackets are not only matched but also properly nested.\n\n[end of description]\n"
    },
    "replace_with_greatest_on_right": {
        "code": "\n\ndef replace_with_greatest_on_right(nums):\n    result = ([0] * len(nums))\n    max_so_far = (- 1)\n    for i in range((len(nums) - 1), (- 1), (- 1)):\n        (result[i], max_so_far) = (max_so_far, max(max_so_far, nums[i]))\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with each integer replaced by the greatest integer to the right of that integer in the original list. For the last element, replace it with -1. The function should not modify the original list.",
        "description": "\n[description for function: replace_with_greatest_on_right]\nThis function takes a list of numbers as input and creates a new list where each element is replaced by the greatest number to its right in the original list. It initializes a result list filled with zeros and a variable to keep track of the maximum value encountered so far, starting from -1. The function iterates through the input list in reverse order, updating the result list with the maximum value found to the right of each element. After processing all elements, it returns the result list. The final output will have the same length as the input list, with each position reflecting the greatest value to the right of that index. If there are no elements to the right, the position will contain -1.\n\n[end of description]\n"
    },
    "sum_of_unique_numbers": {
        "code": "\n\ndef sum_of_unique_numbers(numbers):\n    frequency = {}\n    for num in numbers:\n        frequency[num] = (frequency.get(num, 0) + 1)\n    unique_sum = sum((num for (num, count) in frequency.items() if (count == 1)))\n    return unique_sum\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of the unique numbers in that list. For example, if the input list is [1, 2, 2, 3, 4, 4], the function should return 1 + 3 = 4.",
        "description": "\n[description for function: sum_of_unique_numbers]\nThis function calculates the sum of all unique numbers in a given list. It first creates a frequency dictionary to count the occurrences of each number. Then, it iterates through the dictionary to sum only those numbers that appear exactly once. Finally, it returns the computed sum of these unique numbers. The function effectively filters out duplicates before performing the summation. Overall, it provides a way to identify and sum distinct elements from the input list.\n\n[end of description]\n"
    },
    "char_frequency_histogram": {
        "code": "\n\ndef char_frequency_histogram(input_string):\n    char_count = {}\n    for char in input_string:\n        lower_char = char.lower()\n        if lower_char.isalpha():\n            if (lower_char in char_count):\n                char_count[lower_char] += 1\n            else:\n                char_count[lower_char] = 1\n    return char_count\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns a dictionary where the keys are characters and the values are the number of times each character appears in the string. The function should ignore case and consider only alphabetic characters.",
        "description": "\n[description for function: char_frequency_histogram]\nThis function takes a string as input and calculates the frequency of each alphabetical character, ignoring case. It initializes an empty dictionary to store character counts. As it iterates through each character in the string, it converts the character to lowercase and checks if it is an alphabetic character. If the character is already in the dictionary, its count is incremented; otherwise, it is added with a count of one. Finally, the function returns the dictionary containing the frequency of each character.\n\n[end of description]\n"
    },
    "find_peak_element": {
        "code": "\n\ndef find_peak_element(arr):\n    n = len(arr)\n    if (n == 0):\n        return None\n    if ((n == 1) or (arr[0] > arr[1])):\n        return 0\n    if (arr[(n - 1)] > arr[(n - 2)]):\n        return (n - 1)\n    for i in range(1, (n - 1)):\n        if ((arr[i] > arr[(i - 1)]) and (arr[i] > arr[(i + 1)])):\n            return i\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the index of the peak element. A peak element is an element that is greater than its neighbors. For the purposes of this problem, we'll consider the first and last elements to be peak elements if they are greater than their one neighbor. If there are multiple peak elements, return the index of any one of them.",
        "description": "\n[description for function: find_peak_element]\nThis function identifies a peak element in a given list of integers, where a peak is defined as an element that is greater than its neighbors. It first checks for edge cases, such as an empty list or if the first or last element is a peak. If neither of these conditions is met, it iterates through the list to find an element that is greater than both its adjacent elements. If a peak is found during the iteration, its index is returned. If no peak exists, the function returns None. The function operates in linear time, making it efficient for this task.\n\n[end of description]\n"
    },
    "find_smallest_missing_positive": {
        "code": "\n\ndef find_smallest_missing_positive(nums):\n    positive_nums = set(filter((lambda x: (x > 0)), nums))\n    i = 1\n    while True:\n        if (i not in positive_nums):\n            return i\n        i += 1\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the smallest positive integer (greater than 0) that does not occur in the list.",
        "description": "\n[description for function: find_smallest_missing_positive]\nThis function identifies the smallest missing positive integer from a list of numbers. It first filters the input list to retain only positive integers and stores them in a set for efficient lookup. Then, it initializes a counter starting from 1 and enters an infinite loop. In each iteration, it checks if the current counter value is absent from the set of positive numbers. If it finds a missing integer, it returns that value. The process continues until the smallest missing positive integer is found.\n\n[end of description]\n"
    },
    "find_smallest_missing_positive_v2": {
        "code": "\n\ndef find_smallest_missing_positive_v2(nums):\n    positive_nums = set(filter((lambda x: (x > 0)), nums))\n    smallest_missing = 1\n    while (smallest_missing in positive_nums):\n        smallest_missing += 1\n    return smallest_missing\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the smallest positive integer (greater than 0) that does not occur in the list. The function should handle lists with both positive and negative integers.",
        "description": "\n[description for function: find_smallest_missing_positive]\nThis function identifies the smallest positive integer that is not present in a given list of numbers. It first filters the list to retain only positive integers and stores them in a set for efficient lookup. Starting from the integer 1, it checks sequentially to see if each integer is present in the set. If an integer is found in the set, it increments the integer and continues the search. The process repeats until it finds an integer that is not in the set. Finally, it returns this smallest missing positive integer.\n\n[end of description]\n"
    },
    "count_integers": {
        "code": "\n\ndef count_integers(int_list):\n    count_dict = {}\n    for num in int_list:\n        if (num in count_dict):\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a dictionary where the keys are the integers and the values are the counts of how often each integer appears in the list.",
        "description": "\n[description for function: count_integers]\nThis function takes a list of integers as input and counts the occurrences of each integer in the list. It initializes an empty dictionary to store the counts. As it iterates through the list, it updates the count for each integer, either by incrementing the existing count or initializing it to one if the integer is encountered for the first time. Finally, it returns the dictionary containing the integers and their corresponding counts. This allows for a quick overview of how many times each integer appears in the input list. The function effectively provides a frequency distribution of the integers.\n\n[end of description]\n"
    },
    "reverse_list": {
        "code": "\n\ndef reverse_list(lst):\n    left = 0\n    right = (len(lst) - 1)\n    while (left < right):\n        temp = lst[left]\n        lst[left] = lst[right]\n        lst[right] = temp\n        left += 1\n        right -= 1\n    return lst\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the list of integers in reverse order. The function should not use the built-in reverse() method or [::-1] slicing. Instead, it should manually swap elements in the list.",
        "description": "\n[description for function: reverse_list]\nThis function takes a list as input and reverses its elements in place. It uses two pointers, one starting from the beginning and the other from the end of the list, to swap elements until they meet in the middle. The process continues until all elements have been swapped, effectively reversing the order of the list. The function modifies the original list and returns it after the reversal is complete. It operates with a time complexity of O(n), where n is the number of elements in the list. The function does not create a new list but alters the existing one directly.\n\n[end of description]\n"
    },
    "symmetric_difference": {
        "code": "\n\ndef symmetric_difference(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    sym_diff_set = (set1 ^ set2)\n    return list(sym_diff_set)\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a new list containing the symmetric difference of the two lists. The symmetric difference should contain elements that are in either of the lists but not in both. The order of elements in the returned list does not matter.",
        "description": "\n[description for function: symmetric_difference]\nThis function takes two lists as input and converts them into sets to eliminate any duplicate values. It then calculates the symmetric difference between the two sets, which includes elements that are in either of the sets but not in both. Finally, the function returns the result as a list, containing the unique elements from both input lists.\n\n[end of description]\n"
    },
    "count_vowels": {
        "code": "\n\ndef count_vowels(input_string):\n    input_string = input_string.lower()\n    vowel_count = 0\n    vowels = 'aeiou'\n    for char in input_string:\n        if (char in vowels):\n            vowel_count += 1\n    return vowel_count\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the number of vowels in that string. The function should be case-insensitive.",
        "description": "\n[description for function: count_vowels]\nThis function takes a string as input and converts it to lowercase to ensure uniformity. It initializes a counter to track the number of vowels found. The function then iterates through each character in the string, checking if it is a vowel (a, e, i, o, u). For every vowel encountered, the counter is incremented. Finally, the function returns the total count of vowels in the input string.\n\n[end of description]\n"
    },
    "is_anagram": {
        "code": "\n\ndef is_anagram(str1, str2):\n    normalized_str1 = ''.join(filter(str.isalpha, str1.lower()))\n    normalized_str2 = ''.join(filter(str.isalpha, str2.lower()))\n    sorted_str1 = sorted(normalized_str1)\n    sorted_str2 = sorted(normalized_str2)\n    return (sorted_str1 == sorted_str2)\n",
        "dependencies": [],
        "task": "Write a Python function that takes two strings and returns True if one string is an anagram of the other, and False otherwise. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "description": "\n[description for function: is_anagram]\nThis function checks if two input strings are anagrams of each other by first normalizing both strings to remove non-alphabetic characters and convert them to lowercase. It then sorts the characters of each normalized string. Finally, it compares the sorted versions of both strings and returns a boolean value indicating whether they are equal, thus confirming if the original strings are anagrams.\n\n[end of description]\n"
    },
    "is_valid_ip": {
        "code": "\n\ndef is_valid_ip(ip_str):\n    octets = ip_str.split('.')\n    if (len(octets) != 4):\n        return False\n    for octet in octets:\n        if ((not octet.isdigit()) or (not (0 <= int(octet) <= 255))):\n            return False\n        if ((len(octet) > 1) and (octet[0] == '0')):\n            return False\n    return True\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns True if the string is a valid IPv4 address, and False otherwise. A valid IPv4 address consists of four octets separated by dots, where each octet is a number from 0 to 255 inclusive.",
        "description": "\n[description for function: is_valid_ip]\nThis function checks whether a given string is a valid IPv4 address. It splits the input string into four octets and verifies that there are exactly four parts. Each octet is checked to ensure it is a digit and falls within the range of 0 to 255. Additionally, it ensures that octets do not have leading zeros unless they are exactly \"0\". If all conditions are met, it returns True; otherwise, it returns False.\n\n[end of description]\n"
    },
    "find_nth_prime": {
        "code": "\n\ndef find_nth_prime(n):\n    if (n < 1):\n        raise ValueError('There is no such thing as the 0th prime or negative prime numbers.')\n    primes = [2]\n    num = 2\n    while (len(primes) < n):\n        num += 1\n        for prime in primes:\n            if (prime > int((num ** 0.5))):\n                primes.append(num)\n                break\n            if ((num % prime) == 0):\n                break\n        else:\n            primes.append(num)\n    return primes[(- 1)]\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns the nth prime number. The function should use a simple algorithm to find prime numbers, such as the Sieve of Eratosthenes or trial division.",
        "description": "\n[description for function: find_nth_prime]\nThis function calculates the nth prime number, where n is a positive integer. It starts by checking if n is less than 1, raising an error if so. The function initializes a list of primes with the first prime number, 2, and then iteratively checks subsequent numbers to determine if they are prime. For each candidate number, it tests divisibility against the known primes up to its square root. If a number is found to be prime, it is added to the list of primes. Finally, the function returns the nth prime from the list.\n\n[end of description]\n"
    },
    "cumulative_sum": {
        "code": "\n\ndef cumulative_sum(input_list):\n    cumulative_sum = 0\n    cumulative_list = []\n    for number in input_list:\n        cumulative_sum += number\n        cumulative_list.append(cumulative_sum)\n    return cumulative_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with each element being the sum of itself and all previous elements in the original list. For example, given the list [1, 2, 3, 4], the function should return [1, 3, 6, 10].",
        "description": "\n[description for function: cumulative_sum]\nThis function takes a list of numbers as input and calculates the cumulative sum of the elements. It initializes a variable to keep track of the running total and an empty list to store the cumulative sums. As it iterates through each number in the input list, it adds the current number to the running total and appends this total to the cumulative list. Finally, it returns the list containing the cumulative sums. The output reflects the progressive addition of the input numbers. This allows users to see how the sum evolves as each element is processed.\n\n[end of description]\n"
    },
    "count_divisible": {
        "code": "\n\ndef count_divisible(int_list, divisor):\n    if (divisor == 0):\n        raise ValueError('Divisor cannot be zero.')\n    count = 0\n    for number in int_list:\n        if (((number != 0) or (divisor > 0)) and ((number % divisor) == 0)):\n            count += 1\n    return count\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the number of elements that are divisible by a given divisor. The function should take two arguments: a list of integers and a non-zero divisor. The output should be an integer representing the count of divisible elements.",
        "description": "\n[description for function: count_divisible]\nThis function counts how many numbers in a given list are divisible by a specified divisor. It first checks if the divisor is zero, raising an error if so, as division by zero is not allowed. It then iterates through each number in the list, checking if the number is either non-zero or if the divisor is positive, and whether the number is divisible by the divisor. For each number that meets these criteria, it increments a count. Finally, the function returns the total count of divisible numbers.\n\n[end of description]\n"
    },
    "find_first_occurrence": {
        "code": "\n\ndef find_first_occurrence(sorted_list, target):\n    (left, right) = (0, (len(sorted_list) - 1))\n    result = (- 1)\n    while (left <= right):\n        mid = ((left + right) // 2)\n        if (sorted_list[mid] == target):\n            result = mid\n            right = (mid - 1)\n        elif (sorted_list[mid] < target):\n            left = (mid + 1)\n        else:\n            right = (mid - 1)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a sorted list of integers and a target integer. The function should return the index of the first occurrence of the target in the list using a binary search algorithm. If the target is not found, return -1.",
        "description": "\n[description for function: find_first_occurrence]\nThis function searches for the first occurrence of a specified target value in a sorted list using a binary search algorithm. It initializes two pointers to represent the current search range and a variable to store the result index. The function iteratively narrows down the search range by comparing the middle element of the current range with the target. If the middle element matches the target, it updates the result and continues searching in the left half to find the first occurrence. If the middle element is less than the target, it adjusts the left pointer to search the right half, and if it's greater, it adjusts the right pointer to search the left half. Finally, it returns the index of the first occurrence or -1 if the target is not found.\n\n[end of description]\n"
    }
}