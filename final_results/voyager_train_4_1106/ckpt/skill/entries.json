{
    "square_list": {
        "code": "\n\ndef square_list(input_list):\n    squared_list = []\n    for number in input_list:\n        squared_list.append((number * number))\n    return squared_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the squares of all the numbers. The function should not modify the original list.",
        "description": "\n[description for function: square_list]\nThis function takes a list of numbers as input and creates a new list containing the squares of each number from the input list. It initializes an empty list to store the squared values. Then, it iterates through each number in the input list, calculates its square, and appends the result to the new list. Finally, the function returns the list of squared numbers. The output list will have the same length as the input list, with each element being the square of the corresponding input element. This function effectively transforms the input list by applying a mathematical operation to each of its elements.\n\n[end of description]\n"
    },
    "unique_elements": {
        "code": "\n\ndef unique_elements(input_list):\n    unique_set = set(input_list)\n    unique_list = list(unique_set)\n    return unique_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list containing only the unique elements from the original list. The order of elements in the returned list does not matter.",
        "description": "\n[description for function: unique_elements]\nThis function takes a list as input and converts it into a set to eliminate any duplicate elements. It then transforms the set back into a list, resulting in a collection of unique elements. The order of elements may not be preserved since sets do not maintain order. Finally, the function returns this list of unique elements. This is useful for situations where only distinct values are needed from a given list. Overall, it provides a simple way to filter out duplicates from a list.\n\n[end of description]\n"
    },
    "find_duplicates": {
        "code": "from collections import Counter\n\ndef find_duplicates(int_list):\n    counts = Counter(int_list)\n    duplicates = {num for (num, count) in counts.items() if (count > 1)}\n    return duplicates\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a set containing all the elements that appear more than once in the list.",
        "description": "\n[description for function: find_duplicates]\nThis function takes a list of integers as input and counts the occurrences of each integer using the Counter class from the collections module. It then creates a set of integers that appear more than once in the list, identifying them as duplicates. Finally, the function returns this set of duplicate integers. The use of a set ensures that each duplicate is listed only once, regardless of how many times it appears in the input list. The function efficiently handles the counting and filtering in a concise manner. Overall, it provides a straightforward way to identify duplicate values in a list of integers.\n\n[end of description]\n"
    },
    "calculate_factorial": {
        "code": "\n\ndef calculate_factorial(n):\n    if (n < 0):\n        raise ValueError('Factorial is not defined for negative numbers.')\n    if (n == 0):\n        return 1\n    result = 1\n    for i in range(1, (n + 1)):\n        result *= i\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that calculates the factorial of a given non-negative integer. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. It is denoted by n!.",
        "description": "\n[description for function: calculate_factorial]\nThis function computes the factorial of a non-negative integer n. It raises a ValueError if n is negative, as factorials are not defined for such values. For n equal to zero, it returns 1, since 0! is defined as 1. For positive integers, it initializes a result variable to 1 and iteratively multiplies it by each integer from 1 to n. Finally, it returns the computed factorial value. The function effectively handles edge cases and performs the calculation using a simple loop.\n\n[end of description]\n"
    },
    "is_palindrome": {
        "code": "\n\ndef is_palindrome(s):\n    normalized_str = s.lower()\n    filtered_str = ''.join((char for char in normalized_str if char.isalnum()))\n    return (filtered_str == filtered_str[::(- 1)])\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns True if the string is a palindrome, and False otherwise. The function should be case-insensitive and ignore all non-alphanumeric characters.",
        "description": "\n[description for function: is_palindrome]\nThis function checks if a given string is a palindrome, which means it reads the same forwards and backwards. It first normalizes the string by converting it to lowercase and filtering out non-alphanumeric characters. Then, it compares the filtered string to its reverse. If both are identical, it returns True, indicating that the string is a palindrome; otherwise, it returns False. The function effectively ignores case and punctuation, focusing solely on the alphanumeric content. This makes it suitable for checking phrases and sentences as well as single words.\n\n[end of description]\n"
    },
    "get_dict_value": {
        "code": "\n\ndef get_dict_value(dictionary, key):\n    if (key in dictionary):\n        return dictionary[key]\n    else:\n        return 'Key not found.'\n",
        "dependencies": [],
        "task": "Write a Python function that takes a dictionary and a key, and returns the value associated with the key. If the key does not exist in the dictionary, the function should return 'Key not found.'",
        "description": "\n[description for function: get_dict_value]\nThis function retrieves the value associated with a specified key from a given dictionary. If the key exists in the dictionary, it returns the corresponding value. If the key is not found, it returns a message indicating that the key is not present. The function effectively handles both scenarios of key existence. It provides a straightforward way to access dictionary values while also managing potential errors. Overall, it enhances the usability of dictionary lookups in Python.\n\n[end of description]\n"
    },
    "first_recurring_character": {
        "code": "\n\ndef first_recurring_character(int_list):\n    seen = set()\n    for num in int_list:\n        if (num in seen):\n            return num\n        seen.add(num)\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the first recurring character. If there is no recurring character, return None.",
        "description": "\n[description for function: first_recurring_character]\nThis function takes a list of integers as input and identifies the first recurring character within that list. It utilizes a set to keep track of the numbers that have already been encountered. As it iterates through the list, it checks if the current number has been seen before; if so, it returns that number as the first recurring character. If no recurring number is found by the end of the list, it returns None. The function effectively provides a quick way to find duplicates in a single pass through the list. Overall, it is efficient and straightforward in its approach to solving the problem.\n\n[end of description]\n"
    },
    "bubble_sort": {
        "code": "\n\ndef bubble_sort(input_list):\n    n = len(input_list)\n    for i in range((n - 1)):\n        for j in range(((n - 1) - i)):\n            if (input_list[j] > input_list[(j + 1)]):\n                (input_list[j], input_list[(j + 1)]) = (input_list[(j + 1)], input_list[j])\n    return input_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the integers sorted in ascending order using the bubble sort algorithm.",
        "description": "\n[description for function: bubble_sort]\nThis function implements the bubble sort algorithm to sort a given list in ascending order by repeatedly comparing adjacent elements and swapping them if they are in the wrong order, effectively \"bubbling\" larger elements to the end of the list. It iterates through the list multiple times, reducing the number of comparisons in each subsequent pass as the largest elements settle at the end. The process continues until the entire list is sorted. The function returns the sorted list after completing the sorting process. It operates with a time complexity of O(n^2) in the worst case, making it less efficient for large datasets. Overall, it provides a straightforward method for sorting a list using a simple comparison-based approach.\n\n[end of description]\n"
    },
    "first_non_repeating_character": {
        "code": "\n\ndef first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if (char in char_count):\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if (char_count[char] == 1):\n            return char\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the first non-repeating character in it. If all characters repeat or the string is empty, return None.",
        "description": "\n[description for function: first_non_repeating_character]\nThis function takes a string as input and counts the occurrences of each character in it. It uses a dictionary to store the count of each character. After counting, it iterates through the string again to find the first character that appears only once. If such a character is found, it is returned; otherwise, the function returns None. This effectively identifies the first non-repeating character in the input string. The function handles both empty strings and strings with all repeating characters gracefully.\n\n[end of description]\n"
    },
    "simulate_producer_consumer": {
        "code": "\n\ndef simulate_producer_consumer(items):\n    queue = []\n    consumed_count = 0\n    for item in items:\n        queue.append(item)\n    while queue:\n        item = queue.pop(0)\n        print(item)\n        consumed_count += 1\n    return consumed_count\n",
        "dependencies": [],
        "task": "Write a Python function that simulates a producer-consumer scenario using a queue. The function should take a list of integers as input, where each integer represents an item produced. The function should process (consume) each item by simply printing it and then return the number of items consumed. Use a simple list to simulate the queue behavior.",
        "description": "\n[description for function: simulate_producer_consumer]\nThis function simulates a producer-consumer scenario by taking a list of items as input and adding them to a queue. It then processes each item in the queue by removing it from the front and printing it. The function keeps track of the number of items consumed during this process. Once all items have been processed, it returns the total count of consumed items. The function effectively demonstrates a simple queue operation where items are produced and consumed sequentially.\n\n[end of description]\n"
    },
    "fibonacci": {
        "code": "\n\ndef fibonacci(n):\n    if (n == 0):\n        return 0\n    elif (n == 1):\n        return 1\n    else:\n        return (fibonacci((n - 1)) + fibonacci((n - 2)))\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns the nth Fibonacci number. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The function should use recursion to calculate the result.",
        "description": "\n[description for function: fibonacci]\nThis function calculates the nth Fibonacci number using a recursive approach. It returns 0 if the input is 0 and 1 if the input is 1. For any other positive integer, it computes the Fibonacci number by summing the two preceding Fibonacci numbers. The function continues to call itself until it reaches the base cases. This results in a straightforward but inefficient implementation due to repeated calculations. Overall, it provides a clear demonstration of recursion in generating Fibonacci numbers.\n\n[end of description]\n"
    },
    "length_of_longest_substring": {
        "code": "\n\ndef length_of_longest_substring(s: str) -> int:\n    char_set = set()\n    max_length = 0\n    start = 0\n    for end in range(len(s)):\n        while (s[end] in char_set):\n            char_set.remove(s[start])\n            start += 1\n        char_set.add(s[end])\n        max_length = max(max_length, ((end - start) + 1))\n    return max_length\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the length of the longest substring without repeating characters.",
        "description": "\n[description for function: length_of_longest_substring]\nThis function calculates the length of the longest substring without repeating characters in a given string. It uses a sliding window approach, maintaining a set of characters currently in the substring. As it iterates through the string, it expands the end of the window and adjusts the start when a duplicate character is found. The maximum length of valid substrings is updated throughout the process. Finally, it returns the length of the longest substring identified. The function efficiently handles the input string in linear time.\n\n[end of description]\n"
    },
    "sort_strings_by_vowel_count": {
        "code": "\n\ndef sort_strings_by_vowel_count(strings):\n\n    def count_vowels(s):\n        return sum((1 for char in s.lower() if (char in 'aeiou')))\n    sorted_strings = sorted(strings, key=(lambda s: ((- count_vowels(s)), s)))\n    return sorted_strings\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a new list with the strings sorted based on the number of vowels they contain. The sort should be in descending order, and in case of a tie, the strings should be sorted alphabetically.",
        "description": "\n[description for function: sort_strings_by_vowel_count]\nThis function takes a list of strings and sorts them based on the number of vowels they contain, prioritizing strings with more vowels. In case of a tie in vowel counts, it sorts the strings alphabetically. The sorting is done in descending order of vowel count, meaning strings with the highest number of vowels appear first. The function converts each string to lowercase to ensure that the vowel count is case-insensitive. Finally, it returns the sorted list of strings.\n\n[end of description]\n"
    },
    "most_frequent_char": {
        "code": "\n\ndef most_frequent_char(s):\n    if (not s):\n        return None\n    frequency = {}\n    for char in s:\n        if (char in frequency):\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    max_char = None\n    max_count = 0\n    for char in s:\n        if (frequency[char] > max_count):\n            max_count = frequency[char]\n            max_char = char\n    return max_char\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the character that appears the most frequently in the string. If there is a tie, return the character that appears first in the string. If the string is empty, return None.",
        "description": "\n[description for function: most_frequent_char]\nThis function takes a string as input and returns the character that appears most frequently within that string. If the input string is empty, it returns None. It first counts the occurrences of each character using a dictionary to store the frequency. Then, it iterates through the string again to determine which character has the highest count. Finally, it returns the character with the maximum frequency. If there are multiple characters with the same maximum frequency, it returns the first one encountered.\n\n[end of description]\n"
    },
    "calculate_expression": {
        "code": "\n\ndef calculate_expression(expression):\n    numbers = expression.split('+')\n    integers = map(int, numbers)\n    return sum(integers)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string representing a mathematical expression consisting of non-negative integers and the plus sign (+) and returns the result of the expression. The function should assume that the input is always a valid expression and that there are no spaces between numbers and operators.",
        "description": "\n[description for function: calculate_expression]\nThis function takes a string representing a mathematical expression consisting of numbers separated by plus signs. It splits the string into individual number components and converts them from strings to integers. After converting, it calculates the sum of these integers. Finally, it returns the total sum as the output. The function effectively handles simple addition operations represented in string format. It assumes that the input expression is well-formed and contains only valid integers.\n\n[end of description]\n"
    },
    "recursive_sum": {
        "code": "\n\ndef recursive_sum(n):\n    if (n == 0):\n        return 0\n    else:\n        return (n + recursive_sum((n - 1)))\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns the sum of all integers from 1 to n using recursion.",
        "description": "\n[description for function: recursive_sum]\nThis function calculates the sum of all integers from 1 to a given non-negative integer n using recursion. It checks if n is zero, in which case it returns 0, indicating the base case of the recursion. If n is not zero, it adds n to the result of the function called with n decremented by 1. This process continues until n reaches zero, at which point the accumulated sum is returned. The function effectively computes the sum by breaking the problem down into smaller subproblems. It demonstrates a classic example of using recursion to solve a mathematical summation problem.\n\n[end of description]\n"
    },
    "selection_sort": {
        "code": "\n\ndef selection_sort(arr):\n    for i in range(len(arr)):\n        min_index = i\n        for j in range((i + 1), len(arr)):\n            if (arr[j] < arr[min_index]):\n                min_index = j\n        (arr[i], arr[min_index]) = (arr[min_index], arr[i])\n    return arr\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the integers sorted in ascending order using the selection sort algorithm.",
        "description": "\n[description for function: selection_sort]\nThis function sorts an array in ascending order using the selection sort algorithm. It iterates through each element of the array, identifying the smallest element in the unsorted portion. Once the smallest element is found, it swaps it with the current element being considered. This process continues until the entire array is sorted. The function modifies the original array and returns the sorted version. The time complexity of this sorting method is O(n^2).\n\n[end of description]\n"
    },
    "is_valid_parentheses": {
        "code": "\n\ndef is_valid_parentheses(s: str) -> bool:\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    stack = []\n    for char in s:\n        if (char in bracket_map.values()):\n            stack.append(char)\n        elif (char in bracket_map):\n            if ((not stack) or (stack[(- 1)] != bracket_map[char])):\n                return False\n            stack.pop()\n    return (not stack)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string containing only '(', ')', '{', '}', '[' and ']', and determines if the input string is valid. A string is considered valid if brackets are closed in the correct order. For example, \"()\" and \"()[]{}\" are valid, but \"(]\" and \"([)]\" are not.",
        "description": "\n[description for function: is_valid_parentheses]\nThis function checks if a string of parentheses is valid by using a stack to track opening brackets and ensuring that each closing bracket corresponds to the most recent unmatched opening bracket. It iterates through each character in the string, pushing opening brackets onto the stack and popping them when a matching closing bracket is found. If a closing bracket does not match the expected opening bracket or if there are unmatched opening brackets left in the stack at the end, the function returns false. If all brackets are matched correctly, it returns true. The function effectively handles different types of brackets, including parentheses, curly braces, and square brackets. Overall, it ensures that the brackets are properly nested and closed.\n\n[end of description]\n"
    },
    "last_person_served": {
        "code": "from collections import deque\n\ndef last_person_served(ticket_numbers):\n    queue = deque(ticket_numbers)\n    while (len(queue) > 1):\n        queue.popleft()\n    return queue[0]\n",
        "dependencies": [],
        "task": "Write a Python function that simulates a basic queue system. The function should take a list of integers representing people's ticket numbers and return the ticket number of the person who will be served last. Use the deque from the collections module to implement the queue.",
        "description": "\n[description for function: last_person_served]\nThe function processes a list of ticket numbers using a queue structure to simulate a serving line. It repeatedly removes the first ticket number until only one remains in the queue. The final ticket number left in the queue is then returned as the result. This effectively identifies the last person who would be served based on the initial order of ticket numbers. The function utilizes a deque for efficient removal of elements from the front of the queue. Overall, it provides a straightforward solution to determine the last ticket holder in a serving scenario.\n\n[end of description]\n"
    },
    "find_common_elements": {
        "code": "\n\ndef find_common_elements(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    common_elements_set = set1.intersection(set2)\n    common_elements_list = list(common_elements_set)\n    return common_elements_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a list containing the elements that are common to both lists without duplicates. The order of the elements in the returned list does not matter.",
        "description": "\n[description for function: find_common_elements]\nThis function takes two lists as input and converts them into sets to eliminate duplicates. It then finds the intersection of these two sets, which contains the elements that are common to both lists. The common elements are converted back into a list format. Finally, the function returns this list of common elements. This approach efficiently identifies shared items between the two input lists. The result is a list containing only the elements that appear in both original lists.\n\n[end of description]\n"
    },
    "find_kth_largest": {
        "code": "import heapq\n\ndef find_kth_largest(nums, k):\n    min_heap = []\n    for num in nums:\n        if (len(min_heap) < k):\n            heapq.heappush(min_heap, num)\n        elif (num > min_heap[0]):\n            heapq.heappop(min_heap)\n            heapq.heappush(min_heap, num)\n    return heapq.heappop(min_heap)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the kth largest element in the list. The function should use a min-heap to efficiently find the kth largest element.",
        "description": "\n[description for function: find_kth_largest]\nThis function finds the k-th largest element in a list of numbers by maintaining a min-heap of size k. It iterates through each number in the input list, adding it to the heap if the heap has fewer than k elements. If the heap is full and the current number is larger than the smallest element in the heap, it replaces the smallest element with the current number. After processing all numbers, the smallest element in the heap, which represents the k-th largest element in the original list, is returned. The use of a min-heap ensures efficient retrieval of the k-th largest element. Overall, the function efficiently handles the problem with a time complexity of O(n log k).\n\n[end of description]\n"
    },
    "length_of_lis": {
        "code": "\n\ndef length_of_lis(nums):\n    if (not nums):\n        return 0\n    dp = ([1] * len(nums))\n    for i in range(len(nums)):\n        for j in range(i):\n            if (nums[j] < nums[i]):\n                dp[i] = max(dp[i], (dp[j] + 1))\n    return max(dp)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the length of the longest increasing subsequence in the list. The function should not modify the original list.",
        "description": "\n[description for function: length_of_lis]\nThis function calculates the length of the longest increasing subsequence in a given list of numbers. It initializes a dynamic programming array to keep track of the longest subsequence lengths at each index. The function iterates through the list, comparing each element with the previous ones to update the lengths based on the increasing condition. Finally, it returns the maximum value from the dynamic programming array, which represents the length of the longest increasing subsequence. If the input list is empty, it returns 0. Overall, it efficiently determines the desired length using a nested loop approach.\n\n[end of description]\n"
    },
    "is_balanced": {
        "code": "\n\ndef is_balanced(s: str) -> bool:\n    bracket_map = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for char in s:\n        if (char in bracket_map.values()):\n            stack.append(char)\n        elif (char in bracket_map):\n            if ((not stack) or (stack[(- 1)] != bracket_map[char])):\n                return False\n            stack.pop()\n    return (len(stack) == 0)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string containing only '(', ')', '[', ']', '{', and '}', and determines if the input string is balanced. A string is balanced if all types of brackets are properly closed and nested. The function should return True if the string is balanced, and False otherwise.",
        "description": "\n[description for function: is_balanced]\nThis function checks if a string containing various types of brackets is balanced. It uses a stack to keep track of opening brackets and matches them with their corresponding closing brackets. As it iterates through the string, it pushes opening brackets onto the stack and pops them when a matching closing bracket is found. If a closing bracket does not match the most recent opening bracket or if there are unmatched opening brackets left in the stack at the end, it returns false. If all brackets are matched correctly, it returns true. The function effectively ensures that every opening bracket has a corresponding and correctly ordered closing bracket.\n\n[end of description]\n"
    },
    "linear_search": {
        "code": "\n\ndef linear_search(int_list, target):\n    for (index, value) in enumerate(int_list):\n        if (value == target):\n            return index\n    return (- 1)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and a target integer. The function should return the index of the target integer in the list if it exists, or -1 if the target is not present.",
        "description": "\n[description for function: linear_search]\nThis function takes a list of integers and a target integer as inputs, and it searches for the target within the list. It iterates through the list, checking each element to see if it matches the target. If a match is found, it returns the index of the target element. If the target is not found after checking all elements, it returns -1. The function effectively implements a linear search algorithm. It is straightforward and operates with a time complexity of O(n).\n\n[end of description]\n"
    },
    "look_and_say": {
        "code": "\n\ndef look_and_say(n):\n    if (n == 0):\n        return '1'\n    current_term = '1'\n    for _ in range(1, n):\n        next_term = ''\n        count = 1\n        for j in range(1, len(current_term)):\n            if (current_term[j] == current_term[(j - 1)]):\n                count += 1\n            else:\n                next_term += (str(count) + current_term[(j - 1)])\n                count = 1\n        next_term += (str(count) + current_term[(- 1)])\n        current_term = next_term\n    return current_term\n",
        "dependencies": [],
        "task": "Write a Python function that takes a non-negative integer n and returns the nth number in the 'look-and-say' sequence. The 'look-and-say' sequence starts with '1' and each subsequent term is derived by describing the previous term. For example, the term after '1' is '11' (one 1), after '11' is '21' (two 1s), after '21' is '1211' (one 2, then one 1), and so on.",
        "description": "\n[description for function: look_and_say]\nThis function generates the nth term of the \"look-and-say\" sequence, starting from the first term, which is '1'. It iteratively constructs each subsequent term by counting consecutive digits in the current term and describing them as a count followed by the digit. If the input is zero, it returns '1' immediately. For each term, it initializes a count and builds the next term by checking each digit against the previous one. The process continues until the desired term is reached, and the final term is returned as a string. The function effectively transforms the sequence based on the counts of digits in each term.\n\n[end of description]\n"
    },
    "count_pairs_with_difference": {
        "code": "\n\ndef count_pairs_with_difference(nums):\n    unique_nums = set(nums)\n    count = 0\n    for num in unique_nums:\n        if ((num + 2) in unique_nums):\n            count += 1\n        if ((num - 2) in unique_nums):\n            count += 1\n    return (count // 2)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the number of distinct pairs of elements that have a difference of 2. The function should handle negative numbers as well.",
        "description": "\n[description for function: count_pairs_with_difference]\nThis function counts the number of unique pairs in a list of numbers that have a difference of exactly 2. It first converts the list into a set to eliminate duplicates and facilitate faster lookups. Then, for each unique number, it checks if either the number plus 2 or the number minus 2 exists in the set. For each valid pair found, it increments a count. Finally, it returns half of the count to account for the fact that each pair is counted twice. The result is the total number of unique pairs with the specified difference.\n\n[end of description]\n"
    },
    "count_characters": {
        "code": "\n\ndef count_characters(input_string):\n    char_count = {}\n    for char in input_string:\n        if (char in char_count):\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    return char_count\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns a dictionary where the keys are characters and the values are the number of times each character appears in the string.",
        "description": "\n[description for function: count_characters]\nThis function takes a string as input and counts the occurrences of each character within that string. It initializes an empty dictionary to store the character counts. As it iterates through each character in the input string, it updates the count for each character in the dictionary. If a character is already present in the dictionary, its count is incremented; otherwise, it is added with a count of one. Finally, the function returns the dictionary containing the character counts. This allows users to easily see how many times each character appears in the input string.\n\n[end of description]\n"
    },
    "sort_strings_by_length": {
        "code": "\n\ndef sort_strings_by_length(strings):\n    return sorted(strings, key=(lambda s: ((- len(s)), s)))\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a new list with the strings sorted in descending order based on their length. If two strings have the same length, they should be sorted alphabetically in ascending order.",
        "description": "\n[description for function: sort_strings_by_length]\nThis function takes a list of strings as input and sorts them primarily by their length in descending order. In cases where multiple strings have the same length, it sorts those strings alphabetically in ascending order. The sorting is achieved using the built-in `sorted` function with a custom key. The key is a tuple that consists of the negative length of the string and the string itself. This ensures that longer strings come first, and among strings of the same length, they are ordered lexicographically. The function returns the sorted list of strings.\n\n[end of description]\n"
    },
    "merge_sort": {
        "code": "\n\ndef merge(left, right):\n    sorted_list = []\n    i = j = 0\n    while ((i < len(left)) and (j < len(right))):\n        if (left[i] < right[j]):\n            sorted_list.append(left[i])\n            i += 1\n        else:\n            sorted_list.append(right[j])\n            j += 1\n    sorted_list.extend(left[i:])\n    sorted_list.extend(right[j:])\n    return sorted_list\n\n\n\n\ndef merge_sort(arr):\n    if (len(arr) <= 1):\n        return arr\n    mid = (len(arr) // 2)\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    sorted_left = merge_sort(left_half)\n    sorted_right = merge_sort(right_half)\n    return merge(sorted_left, sorted_right)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the integers sorted in ascending order using the merge sort algorithm. The function should not modify the original list.",
        "description": "\n[description for function: merge_sort]\nThis function sorts an array using the merge sort algorithm, which is a divide-and-conquer approach. It first checks if the array has one or fewer elements, in which case it is already sorted and returned. If the array has more elements, it splits the array into two halves and recursively sorts each half. After sorting both halves, it merges them back together in sorted order. The merging process involves comparing elements from both halves and combining them into a new sorted list. The final result is a fully sorted array.\n\n[end of description]\n"
    },
    "sum_of_two_largest": {
        "code": "\n\ndef sum_of_two_largest(numbers):\n    largest = find_kth_largest(numbers, 1)\n    second_largest = find_kth_largest(numbers, 2)\n    return (largest + second_largest)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of the two largest numbers in the list. The function should handle lists with at least two integers and should not modify the original list.",
        "description": "\n[description for function: sum_of_two_largest]\nThis function calculates the sum of the two largest numbers in a given list. It first identifies the largest number by finding the first largest element. Then, it determines the second largest number by finding the second largest element in the list. Finally, it returns the sum of these two largest numbers. The function effectively handles the task of extracting and summing the top two values from the input list. It assumes that the list contains at least two distinct numbers.\n\n[end of description]\n"
    },
    "first_duplicate": {
        "code": "\n\ndef first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if (num in seen):\n            return num\n        seen.add(num)\n    return (- 1)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the first duplicate number for which the second occurrence has the minimal index. If there are no duplicates, return -1.",
        "description": "\n[description for function: first_duplicate]\nThis function takes a list of integers as input and aims to find the first duplicate number in the list. It utilizes a set to keep track of the numbers that have already been encountered. As it iterates through the list, it checks if the current number is already in the set; if so, it returns that number as the first duplicate. If no duplicates are found by the end of the iteration, it returns -1. The function efficiently identifies duplicates with a time complexity of O(n) due to the use of a set for constant time lookups. Overall, it provides a straightforward solution to the problem of finding the first duplicate in a list.\n\n[end of description]\n"
    },
    "product_except_self": {
        "code": "\n\ndef product_except_self(nums):\n    n = len(nums)\n    left_products = ([1] * n)\n    right_products = ([1] * n)\n    result = ([0] * n)\n    for i in range(1, n):\n        left_products[i] = (left_products[(i - 1)] * nums[(i - 1)])\n    for i in range((n - 2), (- 1), (- 1)):\n        right_products[i] = (right_products[(i + 1)] * nums[(i + 1)])\n    for i in range(n):\n        result[i] = (left_products[i] * right_products[i])\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the product of all the elements in the list except for the current index. For each index, you should find the product of all the integers except the integer at that index, without using division. The function should return a new list with the products.",
        "description": "\n[description for function: product_except_self]\nThis function calculates the product of all elements in an input list except for the element at the current index, without using division. It initializes two lists to store the cumulative products from the left and right sides of each index. The function iterates through the input list to fill these left and right product lists. Finally, it multiplies the corresponding values from the left and right lists to produce the final result. The output is a new list where each element represents the product of all other elements in the input list. This approach ensures that the solution runs in linear time and uses constant space for the output.\n\n[end of description]\n"
    },
    "most_frequent_integer": {
        "code": "\n\ndef most_frequent_integer(int_list):\n    if (not int_list):\n        return None\n    frequency = {}\n    for num in int_list:\n        frequency[num] = (frequency.get(num, 0) + 1)\n    max_count = 0\n    most_frequent = None\n    for (num, count) in frequency.items():\n        if ((count > max_count) or ((count == max_count) and ((most_frequent is None) or (num < most_frequent)))):\n            max_count = count\n            most_frequent = num\n    return most_frequent\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the most frequent integer in the list. If there is a tie, return the smallest integer among the most frequent ones. If the list is empty, return None.",
        "description": "\n[description for function: most_frequent_integer]\nThis function takes a list of integers as input and returns the most frequently occurring integer in that list. If the list is empty, it returns None. It counts the occurrences of each integer using a dictionary to track their frequencies. After counting, it determines which integer has the highest frequency, and in case of a tie, it selects the smallest integer. Finally, it returns the integer that is most frequent.\n\n[end of description]\n"
    },
    "insertion_sort": {
        "code": "\n\ndef insertion_sort(original_list):\n    sorted_list = []\n    for number in original_list:\n        index = 0\n        while ((index < len(sorted_list)) and (sorted_list[index] < number)):\n            index += 1\n        sorted_list.insert(index, number)\n    return sorted_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with the integers sorted in ascending order using the insertion sort algorithm. The function should not modify the original list.",
        "description": "\n[description for function: insertion_sort]\nThis function takes a list of numbers as input and sorts it using the insertion sort algorithm. It initializes an empty list to hold the sorted elements. For each number in the original list, it finds the appropriate index in the sorted list where the number should be inserted. The number is then inserted at that index, maintaining the order of the sorted list. Finally, the function returns the newly sorted list. This approach ensures that the list is built up in a sorted manner as each element is processed.\n\n[end of description]\n"
    },
    "is_balanced_v2": {
        "code": "\n\ndef is_balanced_v2(s: str) -> bool:\n    stack = []\n    bracket_map = {')': '(', ']': '[', '}': '{'}\n    for char in s:\n        if (char in bracket_map.values()):\n            stack.append(char)\n        elif (char in bracket_map):\n            if ((not stack) or (stack[(- 1)] != bracket_map[char])):\n                return False\n            stack.pop()\n    return (not stack)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string containing only '(', ')', '[', ']', '{', and '}', and determines if the input string has balanced parentheses, brackets, and braces. A string is balanced if all types of brackets are correctly closed and nested. The function should return True if the string is balanced, and False otherwise.",
        "description": "\n[description for function: is_balanced]\nThis function checks if a string containing various types of brackets (parentheses, square brackets, and curly braces) is balanced, meaning that every opening bracket has a corresponding closing bracket in the correct order. It uses a stack to keep track of the opening brackets encountered as it iterates through the string. When a closing bracket is found, it checks if it matches the most recent opening bracket on the stack. If there is a mismatch or if a closing bracket appears without a corresponding opening bracket, the function returns False. At the end of the iteration, if the stack is empty, it indicates that all brackets were properly closed, and the function returns True; otherwise, it returns False. This ensures that the brackets are not only matched but also properly nested.\n\n[end of description]\n"
    },
    "replace_with_greatest_on_right": {
        "code": "\n\ndef replace_with_greatest_on_right(nums):\n    result = ([0] * len(nums))\n    max_so_far = (- 1)\n    for i in range((len(nums) - 1), (- 1), (- 1)):\n        (result[i], max_so_far) = (max_so_far, max(max_so_far, nums[i]))\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with each integer replaced by the greatest integer to the right of that integer in the original list. For the last element, replace it with -1. The function should not modify the original list.",
        "description": "\n[description for function: replace_with_greatest_on_right]\nThis function takes a list of numbers as input and creates a new list where each element is replaced by the greatest number to its right in the original list. It initializes a result list filled with zeros and a variable to keep track of the maximum value encountered so far, starting from -1. The function iterates through the input list in reverse order, updating the result list with the maximum value found to the right of each element. After processing all elements, it returns the result list. The final output will have the same length as the input list, with each position reflecting the greatest value to the right of that index. If there are no elements to the right, the position will contain -1.\n\n[end of description]\n"
    },
    "sum_of_unique_numbers": {
        "code": "\n\ndef sum_of_unique_numbers(numbers):\n    frequency = {}\n    for num in numbers:\n        frequency[num] = (frequency.get(num, 0) + 1)\n    unique_sum = sum((num for (num, count) in frequency.items() if (count == 1)))\n    return unique_sum\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of the unique numbers in that list. For example, if the input list is [1, 2, 2, 3, 4, 4], the function should return 1 + 3 = 4.",
        "description": "\n[description for function: sum_of_unique_numbers]\nThis function calculates the sum of all unique numbers in a given list. It first creates a frequency dictionary to count the occurrences of each number. Then, it iterates through the dictionary to sum only those numbers that appear exactly once. Finally, it returns the computed sum of these unique numbers. The function effectively filters out duplicates before performing the summation. Overall, it provides a way to identify and sum distinct elements from the input list.\n\n[end of description]\n"
    },
    "char_frequency_histogram": {
        "code": "\n\ndef char_frequency_histogram(input_string):\n    char_count = {}\n    for char in input_string:\n        lower_char = char.lower()\n        if lower_char.isalpha():\n            if (lower_char in char_count):\n                char_count[lower_char] += 1\n            else:\n                char_count[lower_char] = 1\n    return char_count\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns a dictionary where the keys are characters and the values are the number of times each character appears in the string. The function should ignore case and consider only alphabetic characters.",
        "description": "\n[description for function: char_frequency_histogram]\nThis function takes a string as input and calculates the frequency of each alphabetical character, ignoring case. It initializes an empty dictionary to store character counts. As it iterates through each character in the string, it converts the character to lowercase and checks if it is an alphabetic character. If the character is already in the dictionary, its count is incremented; otherwise, it is added with a count of one. Finally, the function returns the dictionary containing the frequency of each character.\n\n[end of description]\n"
    },
    "find_peak_element": {
        "code": "\n\ndef find_peak_element(arr):\n    n = len(arr)\n    if (n == 0):\n        return None\n    if ((n == 1) or (arr[0] > arr[1])):\n        return 0\n    if (arr[(n - 1)] > arr[(n - 2)]):\n        return (n - 1)\n    for i in range(1, (n - 1)):\n        if ((arr[i] > arr[(i - 1)]) and (arr[i] > arr[(i + 1)])):\n            return i\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the index of the peak element. A peak element is an element that is greater than its neighbors. For the purposes of this problem, we'll consider the first and last elements to be peak elements if they are greater than their one neighbor. If there are multiple peak elements, return the index of any one of them.",
        "description": "\n[description for function: find_peak_element]\nThis function identifies a peak element in a given list of integers, where a peak is defined as an element that is greater than its neighbors. It first checks for edge cases, such as an empty list or if the first or last element is a peak. If neither of these conditions is met, it iterates through the list to find an element that is greater than both its adjacent elements. If a peak is found during the iteration, its index is returned. If no peak exists, the function returns None. The function operates in linear time, making it efficient for this task.\n\n[end of description]\n"
    },
    "find_smallest_missing_positive": {
        "code": "\n\ndef find_smallest_missing_positive(nums):\n    positive_nums = set(filter((lambda x: (x > 0)), nums))\n    i = 1\n    while True:\n        if (i not in positive_nums):\n            return i\n        i += 1\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the smallest positive integer (greater than 0) that does not occur in the list.",
        "description": "\n[description for function: find_smallest_missing_positive]\nThis function identifies the smallest missing positive integer from a list of numbers. It first filters the input list to retain only positive integers and stores them in a set for efficient lookup. Then, it initializes a counter starting from 1 and enters an infinite loop. In each iteration, it checks if the current counter value is absent from the set of positive numbers. If it finds a missing integer, it returns that value. The process continues until the smallest missing positive integer is found.\n\n[end of description]\n"
    },
    "find_smallest_missing_positive_v2": {
        "code": "\n\ndef find_smallest_missing_positive_v2(nums):\n    positive_nums = set(filter((lambda x: (x > 0)), nums))\n    smallest_missing = 1\n    while (smallest_missing in positive_nums):\n        smallest_missing += 1\n    return smallest_missing\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the smallest positive integer (greater than 0) that does not occur in the list. The function should handle lists with both positive and negative integers.",
        "description": "\n[description for function: find_smallest_missing_positive]\nThis function identifies the smallest positive integer that is not present in a given list of numbers. It first filters the list to retain only positive integers and stores them in a set for efficient lookup. Starting from the integer 1, it checks sequentially to see if each integer is present in the set. If an integer is found in the set, it increments the integer and continues the search. The process repeats until it finds an integer that is not in the set. Finally, it returns this smallest missing positive integer.\n\n[end of description]\n"
    },
    "count_integers": {
        "code": "\n\ndef count_integers(int_list):\n    count_dict = {}\n    for num in int_list:\n        if (num in count_dict):\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a dictionary where the keys are the integers and the values are the counts of how often each integer appears in the list.",
        "description": "\n[description for function: count_integers]\nThis function takes a list of integers as input and counts the occurrences of each integer in the list. It initializes an empty dictionary to store the counts. As it iterates through the list, it updates the count for each integer, either by incrementing the existing count or initializing it to one if the integer is encountered for the first time. Finally, it returns the dictionary containing the integers and their corresponding counts. This allows for a quick overview of how many times each integer appears in the input list. The function effectively provides a frequency distribution of the integers.\n\n[end of description]\n"
    },
    "reverse_list": {
        "code": "\n\ndef reverse_list(lst):\n    left = 0\n    right = (len(lst) - 1)\n    while (left < right):\n        temp = lst[left]\n        lst[left] = lst[right]\n        lst[right] = temp\n        left += 1\n        right -= 1\n    return lst\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the list of integers in reverse order. The function should not use the built-in reverse() method or [::-1] slicing. Instead, it should manually swap elements in the list.",
        "description": "\n[description for function: reverse_list]\nThis function takes a list as input and reverses its elements in place. It uses two pointers, one starting from the beginning and the other from the end of the list, to swap elements until they meet in the middle. The process continues until all elements have been swapped, effectively reversing the order of the list. The function modifies the original list and returns it after the reversal is complete. It operates with a time complexity of O(n), where n is the number of elements in the list. The function does not create a new list but alters the existing one directly.\n\n[end of description]\n"
    },
    "symmetric_difference": {
        "code": "\n\ndef symmetric_difference(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    sym_diff_set = (set1 ^ set2)\n    return list(sym_diff_set)\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a new list containing the symmetric difference of the two lists. The symmetric difference should contain elements that are in either of the lists but not in both. The order of elements in the returned list does not matter.",
        "description": "\n[description for function: symmetric_difference]\nThis function takes two lists as input and converts them into sets to eliminate any duplicate values. It then calculates the symmetric difference between the two sets, which includes elements that are in either of the sets but not in both. Finally, the function returns the result as a list, containing the unique elements from both input lists.\n\n[end of description]\n"
    },
    "count_vowels": {
        "code": "\n\ndef count_vowels(input_string):\n    input_string = input_string.lower()\n    vowel_count = 0\n    vowels = 'aeiou'\n    for char in input_string:\n        if (char in vowels):\n            vowel_count += 1\n    return vowel_count\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the number of vowels in that string. The function should be case-insensitive.",
        "description": "\n[description for function: count_vowels]\nThis function takes a string as input and converts it to lowercase to ensure uniformity. It initializes a counter to track the number of vowels found. The function then iterates through each character in the string, checking if it is a vowel (a, e, i, o, u). For every vowel encountered, the counter is incremented. Finally, the function returns the total count of vowels in the input string.\n\n[end of description]\n"
    },
    "is_anagram": {
        "code": "\n\ndef is_anagram(str1, str2):\n    normalized_str1 = ''.join(filter(str.isalpha, str1.lower()))\n    normalized_str2 = ''.join(filter(str.isalpha, str2.lower()))\n    sorted_str1 = sorted(normalized_str1)\n    sorted_str2 = sorted(normalized_str2)\n    return (sorted_str1 == sorted_str2)\n",
        "dependencies": [],
        "task": "Write a Python function that takes two strings and returns True if one string is an anagram of the other, and False otherwise. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "description": "\n[description for function: is_anagram]\nThis function checks if two input strings are anagrams of each other by first normalizing both strings to remove non-alphabetic characters and convert them to lowercase. It then sorts the characters of each normalized string. Finally, it compares the sorted versions of both strings and returns a boolean value indicating whether they are equal, thus confirming if the original strings are anagrams.\n\n[end of description]\n"
    },
    "is_valid_ip": {
        "code": "\n\ndef is_valid_ip(ip_str):\n    octets = ip_str.split('.')\n    if (len(octets) != 4):\n        return False\n    for octet in octets:\n        if ((not octet.isdigit()) or (not (0 <= int(octet) <= 255))):\n            return False\n        if ((len(octet) > 1) and (octet[0] == '0')):\n            return False\n    return True\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns True if the string is a valid IPv4 address, and False otherwise. A valid IPv4 address consists of four octets separated by dots, where each octet is a number from 0 to 255 inclusive.",
        "description": "\n[description for function: is_valid_ip]\nThis function checks whether a given string is a valid IPv4 address. It splits the input string into four octets and verifies that there are exactly four parts. Each octet is checked to ensure it is a digit and falls within the range of 0 to 255. Additionally, it ensures that octets do not have leading zeros unless they are exactly \"0\". If all conditions are met, it returns True; otherwise, it returns False.\n\n[end of description]\n"
    },
    "find_nth_prime": {
        "code": "\n\ndef find_nth_prime(n):\n    if (n < 1):\n        raise ValueError('There is no such thing as the 0th prime or negative prime numbers.')\n    primes = [2]\n    num = 2\n    while (len(primes) < n):\n        num += 1\n        for prime in primes:\n            if (prime > int((num ** 0.5))):\n                primes.append(num)\n                break\n            if ((num % prime) == 0):\n                break\n        else:\n            primes.append(num)\n    return primes[(- 1)]\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns the nth prime number. The function should use a simple algorithm to find prime numbers, such as the Sieve of Eratosthenes or trial division.",
        "description": "\n[description for function: find_nth_prime]\nThis function calculates the nth prime number, where n is a positive integer. It starts by checking if n is less than 1, raising an error if so. The function initializes a list of primes with the first prime number, 2, and then iteratively checks subsequent numbers to determine if they are prime. For each candidate number, it tests divisibility against the known primes up to its square root. If a number is found to be prime, it is added to the list of primes. Finally, the function returns the nth prime from the list.\n\n[end of description]\n"
    },
    "cumulative_sum": {
        "code": "\n\ndef cumulative_sum(input_list):\n    cumulative_sum = 0\n    cumulative_list = []\n    for number in input_list:\n        cumulative_sum += number\n        cumulative_list.append(cumulative_sum)\n    return cumulative_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with each element being the sum of itself and all previous elements in the original list. For example, given the list [1, 2, 3, 4], the function should return [1, 3, 6, 10].",
        "description": "\n[description for function: cumulative_sum]\nThis function takes a list of numbers as input and calculates the cumulative sum of the elements. It initializes a variable to keep track of the running total and an empty list to store the cumulative sums. As it iterates through each number in the input list, it adds the current number to the running total and appends this total to the cumulative list. Finally, it returns the list containing the cumulative sums. The output reflects the progressive addition of the input numbers. This allows users to see how the sum evolves as each element is processed.\n\n[end of description]\n"
    },
    "count_divisible": {
        "code": "\n\ndef count_divisible(int_list, divisor):\n    if (divisor == 0):\n        raise ValueError('Divisor cannot be zero.')\n    count = 0\n    for number in int_list:\n        if (((number != 0) or (divisor > 0)) and ((number % divisor) == 0)):\n            count += 1\n    return count\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the number of elements that are divisible by a given divisor. The function should take two arguments: a list of integers and a non-zero divisor. The output should be an integer representing the count of divisible elements.",
        "description": "\n[description for function: count_divisible]\nThis function counts how many numbers in a given list are divisible by a specified divisor. It first checks if the divisor is zero, raising an error if so, as division by zero is not allowed. It then iterates through each number in the list, checking if the number is either non-zero or if the divisor is positive, and whether the number is divisible by the divisor. For each number that meets these criteria, it increments a count. Finally, the function returns the total count of divisible numbers.\n\n[end of description]\n"
    },
    "find_first_occurrence": {
        "code": "\n\ndef find_first_occurrence(sorted_list, target):\n    (left, right) = (0, (len(sorted_list) - 1))\n    result = (- 1)\n    while (left <= right):\n        mid = ((left + right) // 2)\n        if (sorted_list[mid] == target):\n            result = mid\n            right = (mid - 1)\n        elif (sorted_list[mid] < target):\n            left = (mid + 1)\n        else:\n            right = (mid - 1)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a sorted list of integers and a target integer. The function should return the index of the first occurrence of the target in the list using a binary search algorithm. If the target is not found, return -1.",
        "description": "\n[description for function: find_first_occurrence]\nThis function searches for the first occurrence of a specified target value in a sorted list using a binary search algorithm. It initializes two pointers to represent the current search range and a variable to store the result index. The function iteratively narrows down the search range by comparing the middle element of the current range with the target. If the middle element matches the target, it updates the result and continues searching in the left half to find the first occurrence. If the middle element is less than the target, it adjusts the left pointer to search the right half, and if it's greater, it adjusts the right pointer to search the left half. Finally, it returns the index of the first occurrence or -1 if the target is not found.\n\n[end of description]\n"
    },
    "count_integer_frequencies": {
        "code": "\n\ndef count_integer_frequencies(int_list):\n    count_dict = {}\n    for num in int_list:\n        if (num in count_dict):\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a dictionary where each key is a unique integer from the list and the corresponding value is the number of times that integer appears in the list.",
        "description": "\n[description for function: count_integer_frequencies]\nThis function takes a list of integers as input and counts the frequency of each integer in the list. It initializes an empty dictionary to store the counts. As it iterates through the list, it checks if each integer is already a key in the dictionary; if so, it increments its count, otherwise, it adds the integer as a new key with a count of one. Finally, it returns the dictionary containing the integers and their corresponding frequencies. This allows for easy retrieval of how many times each integer appears in the input list. The function effectively summarizes the occurrences of integers in a given collection.\n\n[end of description]\n"
    },
    "find_intersection": {
        "code": "\n\ndef find_intersection(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    intersection_set = set1.intersection(set2)\n    intersection_list = list(intersection_set)\n    return intersection_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a new list containing the intersection of the two lists. The intersection should contain elements that are common to both lists without duplicates. The order of the elements in the returned list does not matter.",
        "description": "\n[description for function: find_intersection]\nThis function takes two lists as input and converts them into sets to eliminate any duplicate values. It then computes the intersection of these two sets, which contains only the elements that are present in both sets. The resulting intersection is converted back into a list format. Finally, the function returns this list of intersecting elements. This approach efficiently identifies common elements between the two input lists. The output will only include unique values that appear in both lists.\n\n[end of description]\n"
    },
    "look_and_say_v2": {
        "code": "\n\ndef look_and_say_v2(n):\n    if (n <= 0):\n        raise ValueError('Input must be a positive integer greater than 0.')\n    current_term = '1'\n    for _ in range(1, n):\n        next_term = ''\n        count = 1\n        for j in range(1, len(current_term)):\n            if (current_term[j] == current_term[(j - 1)]):\n                count += 1\n            else:\n                next_term += (str(count) + current_term[(j - 1)])\n                count = 1\n        next_term += (str(count) + current_term[(- 1)])\n        current_term = next_term\n    return current_term\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns the nth number in the 'look-and-say' sequence. The 'look-and-say' sequence starts with '1' and each subsequent term is derived by describing the previous term. For example, the term after '1' is '11' (one 1), after '11' is '21' (two 1s), after '21' is '1211' (one 2, then one 1), and so on. The function should handle n being a positive integer greater than 0.",
        "description": "\n[description for function: look_and_say]\nThis function generates the nth term of the \"look-and-say\" sequence, which is a series of numbers where each term is derived from describing the digits of the previous term. It starts with the initial term '1' and iteratively constructs each subsequent term by counting consecutive digits and expressing that count followed by the digit itself. If the input is less than or equal to zero, it raises a ValueError. The function uses a loop to build the next term based on the current term until it reaches the desired term number. Finally, it returns the nth term as a string. The sequence begins with '1', followed by '11', '21', '1211', and so on.\n\n[end of description]\n"
    },
    "filter_prime_numbers": {
        "code": "\n\ndef filter_prime_numbers(int_list):\n\n    def is_prime(n):\n        if (n <= 1):\n            return False\n        for i in range(2, (int((n ** 0.5)) + 1)):\n            if ((n % i) == 0):\n                return False\n        return True\n    prime_list = [num for num in int_list if is_prime(num)]\n    return prime_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list containing only the elements that are prime numbers. The function should not modify the original list.",
        "description": "\n[description for function: filter_prime_numbers]\nThis function takes a list of integers as input and returns a new list containing only the prime numbers from the original list. It first checks each number to determine if it is prime by testing divisibility from 2 up to the square root of the number. If a number is found to be prime, it is included in the resulting list. The final output is a list of all prime numbers extracted from the input list. If there are no prime numbers, an empty list is returned. The function effectively filters out non-prime numbers, providing a concise collection of primes.\n\n[end of description]\n"
    },
    "sum_of_smallest": {
        "code": "\n\ndef sum_of_smallest(numbers):\n    if (len(numbers) < 2):\n        raise ValueError('List must contain at least two integers.')\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for number in numbers:\n        if (number < smallest):\n            second_smallest = smallest\n            smallest = number\n        elif (number < second_smallest):\n            second_smallest = number\n    return (smallest + second_smallest)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the sum of the two smallest numbers in the list. The function should handle lists with at least two integers and should not modify the original list.",
        "description": "\n[description for function: sum_of_smallest]\nThis function calculates the sum of the two smallest integers in a given list. It first checks if the list contains at least two integers, raising an error if not. It initializes two variables to track the smallest and second smallest numbers. As it iterates through the list, it updates these variables accordingly. Finally, it returns the sum of the two smallest integers found.\n\n[end of description]\n"
    },
    "increment_list_elements": {
        "code": "\n\ndef increment_list_elements(input_list):\n    incremented_list = []\n    for number in input_list:\n        incremented_list.append((number + 1))\n    return incremented_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns a new list with each element incremented by 1. The function should not modify the original list.",
        "description": "\n[description for function: increment_list_elements]\nThis function takes a list of numbers as input and creates a new list by adding one to each element of the input list. It initializes an empty list to store the incremented values. It then iterates through each number in the input list, increments it by one, and appends the result to the new list. Finally, the function returns the new list containing all the incremented values. The output list will have the same length as the input list, with each element increased by one. This function effectively transforms the input list by applying a simple arithmetic operation to each of its elements.\n\n[end of description]\n"
    },
    "bfs_traversal": {
        "code": "from collections import deque\n\ndef bfs_traversal(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    order_of_visit = []\n    while queue:\n        current_node = queue.popleft()\n        order_of_visit.append(current_node)\n        for neighbor in graph[current_node]:\n            if (neighbor not in visited):\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return order_of_visit\n",
        "dependencies": [],
        "task": "Write a Python function that performs a breadth-first search (BFS) on a graph represented as an adjacency list. The function should take two arguments: the graph as a dictionary where keys are nodes and values are lists of adjacent nodes, and the starting node. The function should return a list of nodes in the order they are visited during the BFS traversal.",
        "description": "\n[description for function: bfs_traversal]\nThis function performs a breadth-first search (BFS) traversal on a given graph starting from a specified node, returning the order in which nodes are visited. It initializes a set to keep track of visited nodes and a queue to manage the nodes to be explored. As it processes each node, it adds unvisited neighbors to the queue and marks them as visited. The traversal continues until all reachable nodes have been explored. Finally, it returns a list representing the order of nodes visited during the traversal. This approach ensures that nodes are explored level by level.\n\n[end of description]\n"
    },
    "has_unique_chars": {
        "code": "\n\ndef has_unique_chars(s):\n    for i in range(len(s)):\n        for j in range((i + 1), len(s)):\n            if (s[i] == s[j]):\n                return False\n    return True\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns True if all the characters in the string are unique, and False otherwise. The function should not use any additional data structures like sets or dictionaries.",
        "description": "\n[description for function: has_unique_chars]\nThis function checks if a given string contains all unique characters. It iterates through each character in the string and compares it with every subsequent character. If it finds any duplicate characters, it returns False. If no duplicates are found after checking all characters, it returns True. The function effectively determines the uniqueness of characters in the input string. It operates with a time complexity of O(n^2) due to the nested loops.\n\n[end of description]\n"
    },
    "find_pair_with_sum": {
        "code": "\n\ndef find_pair_with_sum(sorted_list, target_sum):\n    left = 0\n    right = (len(sorted_list) - 1)\n    while (left < right):\n        current_sum = (sorted_list[left] + sorted_list[right])\n        if (current_sum == target_sum):\n            return (sorted_list[left], sorted_list[right])\n        elif (current_sum < target_sum):\n            left += 1\n        else:\n            right -= 1\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a sorted list of integers and a target sum. The function should return a tuple of two integers from the list that add up to the target sum. If no such pair exists, return None. This task will utilize the two-pointer technique.",
        "description": "\n[description for function: find_pair_with_sum]\nThis function takes a sorted list and a target sum as inputs, aiming to find a pair of numbers within the list that add up to the target sum. It uses a two-pointer approach, initializing one pointer at the beginning and the other at the end of the list. As it iterates, it calculates the sum of the values at these pointers and compares it to the target sum. If a match is found, it returns the pair; if the current sum is less than the target, it moves the left pointer to the right to increase the sum, and if it's greater, it moves the right pointer to the left to decrease the sum. The process continues until the pointers meet, at which point it returns None if no pair is found. This method is efficient, operating in linear time due to the sorted nature of the input list.\n\n[end of description]\n"
    },
    "depth_first_search": {
        "code": "\n\ndef depth_first_search(graph, start):\n    visited_order = []\n    visited = set()\n\n    def dfs_helper(node):\n        if (node not in visited):\n            visited.add(node)\n            visited_order.append(node)\n            for neighbor in graph[node]:\n                dfs_helper(neighbor)\n    dfs_helper(start)\n    return visited_order\n",
        "dependencies": [],
        "task": "Write a Python function that performs a depth-first search (DFS) on a graph represented as an adjacency list. The function should take two arguments: the graph as a dictionary where keys are nodes and values are lists of adjacent nodes, and the starting node. The function should return a list of nodes in the order they are visited during the DFS traversal.",
        "description": "\n[description for function: depth_first_search]\nThis function performs a depth-first search (DFS) on a given graph starting from a specified node. It maintains a list to record the order of visited nodes and a set to track which nodes have already been visited. The search explores as far as possible along each branch before backtracking. For each unvisited neighbor of the current node, it recursively visits that neighbor. Finally, it returns the order in which the nodes were visited. This approach is useful for traversing or searching tree or graph data structures.\n\n[end of description]\n"
    },
    "quicksort": {
        "code": "\n\ndef quicksort(arr):\n    if (len(arr) <= 1):\n        return arr\n    pivot = arr[0]\n    less_than_pivot = [x for x in arr[1:] if (x < pivot)]\n    equal_to_pivot = [x for x in arr if (x == pivot)]\n    greater_than_pivot = [x for x in arr[1:] if (x > pivot)]\n    return ((quicksort(less_than_pivot) + equal_to_pivot) + quicksort(greater_than_pivot))\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the list of integers sorted in ascending order using the quicksort algorithm. The function should not modify the original list.",
        "description": "\n[description for function: quicksort]\nThis function implements the quicksort algorithm to sort an array. It first checks if the array has one or no elements, in which case it returns the array as is. A pivot element is selected, and the array is partitioned into three lists: elements less than the pivot, elements equal to the pivot, and elements greater than the pivot. The function then recursively sorts the lists of elements less than and greater than the pivot. Finally, it combines the sorted lists and the pivot elements to produce the sorted array. The overall time complexity of this sorting method is average O(n log n).\n\n[end of description]\n"
    },
    "min_num_squares": {
        "code": "\n\ndef min_num_squares(n):\n    dp = ([float('inf')] * (n + 1))\n    dp[0] = 0\n    for i in range(1, (n + 1)):\n        j = 1\n        while ((j * j) <= i):\n            dp[i] = min(dp[i], (dp[(i - (j * j))] + 1))\n            j += 1\n    return dp[n]\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer `n` and returns the minimum number of squares whose sum equals `n`. This is a classic dynamic programming problem where you need to find the least number of perfect square numbers which sum to `n`. For example, given `n = 12`, the answer should be `3` because `12 = 4 + 4 + 4`.",
        "description": "\n[description for function: min_num_squares]\nThis function calculates the minimum number of perfect square numbers that sum up to a given integer n. It uses dynamic programming to build an array where each index represents the minimum count of squares needed for that index value. Initially, it sets the count for zero to zero and all other counts to infinity. For each integer from 1 to n, it checks all perfect squares less than or equal to that integer and updates the count based on previously computed values. Finally, it returns the minimum count for the input integer n. This approach efficiently determines the solution by leveraging previously computed results.\n\n[end of description]\n"
    },
    "length_of_longest_substring_v2": {
        "code": "\n\ndef length_of_longest_substring_v2(s: str) -> int:\n    char_set = set()\n    max_length = 0\n    start = 0\n    for end in range(len(s)):\n        while (s[end] in char_set):\n            char_set.remove(s[start])\n            start += 1\n        char_set.add(s[end])\n        max_length = max(max_length, ((end - start) + 1))\n    return max_length\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns the length of the longest substring without repeating characters. The function should use the sliding window technique to efficiently solve the problem.",
        "description": "\n[description for function: length_of_longest_substring]\nThis function calculates the length of the longest substring without repeating characters in a given string. It uses a sliding window approach, maintaining a set of characters currently in the substring. As it iterates through the string, it expands the end of the window and adjusts the start when a duplicate character is found. The maximum length of valid substrings is updated throughout the process. Finally, it returns the length of the longest substring identified. The function efficiently handles the input string in linear time.\n\n[end of description]\n"
    },
    "min_steps_to_zero": {
        "code": "\n\ndef min_steps_to_zero(n):\n    dp = ([0] * (n + 1))\n    for i in range(1, (n + 1)):\n        dp[i] = (dp[(i - 1)] + 1)\n        if ((i % 2) == 0):\n            dp[i] = min(dp[i], (dp[(i // 2)] + 1))\n    return dp[n]\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer `n` and returns the minimum number of steps to reduce it to zero. In one step, you can either decrement `n` by 1 or, if `n` is even, divide `n` by 2. The function should use dynamic programming to efficiently solve the problem.",
        "description": "\n[description for function: min_steps_to_zero]\nThis function calculates the minimum number of steps required to reduce a given positive integer to zero, where in each step, the integer can either be decremented by one or divided by two if it is even. It uses dynamic programming to build an array that stores the minimum steps for each integer from 0 to n. The function initializes a list to keep track of the steps and iteratively fills it by considering both possible operations for each integer. For each integer, it updates the minimum steps based on the previous values in the list. Finally, it returns the minimum steps needed for the input integer n. The approach ensures that the solution is efficient and avoids redundant calculations.\n\n[end of description]\n"
    },
    "recursive_sum_v2": {
        "code": "\n\ndef recursive_sum_v2(n):\n    if (n == 0):\n        return 0\n    else:\n        return (n + recursive_sum_v2((n - 1)))\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns the sum of all integers from 1 to n using recursion. The function should handle positive integers greater than 0.",
        "description": "\n[description for function: recursive_sum]\nThis function calculates the sum of all integers from 1 to a given non-negative integer n using recursion. It checks if n is zero, in which case it returns 0, indicating the base case of the recursion. If n is not zero, it adds n to the result of the function called with n decremented by 1. This process continues until n reaches zero, at which point the accumulated sum is returned. The function effectively computes the sum by breaking the problem down into smaller subproblems. It demonstrates a classic example of using recursion to solve a mathematical summation problem.\n\n[end of description]\n"
    },
    "find_majority_element": {
        "code": "\n\ndef find_majority_element(nums):\n    n = len(nums)\n    count = {}\n    for num in nums:\n        count[num] = (count.get(num, 0) + 1)\n    for (num, cnt) in count.items():\n        if (cnt > (n / 2)):\n            return num\n    return None\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the majority element if it exists. The majority element is the element that appears more than n/2 times in the list, where n is the size of the list. If no majority element exists, the function should return None.",
        "description": "\n[description for function: find_majority_element]\nThis function takes a list of numbers as input and determines if there is a majority element, which is defined as an element that appears more than half the time in the list. It first calculates the frequency of each element using a dictionary. After counting the occurrences, it checks if any element's count exceeds half the length of the list. If such an element is found, it returns that element; otherwise, it returns None. The function efficiently handles the counting and checking in a single pass through the data. Overall, it provides a straightforward way to identify a majority element in a given list.\n\n[end of description]\n"
    },
    "find_kth_smallest": {
        "code": "import heapq\n\ndef find_kth_smallest(nums, k):\n    if (k > len(nums)):\n        return None\n    min_heap = []\n    for num in nums:\n        heapq.heappush(min_heap, num)\n    for _ in range((k - 1)):\n        heapq.heappop(min_heap)\n    return heapq.heappop(min_heap)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and an integer k, and returns the kth smallest element in the list using a min-heap. If k is larger than the number of elements in the list, return None.",
        "description": "\n[description for function: find_kth_smallest]\nThis function takes a list of numbers and an integer k as input, aiming to find the k-th smallest element in the list. It first checks if k is greater than the length of the list, returning None if true. A min-heap is created to store the numbers, allowing for efficient retrieval of the smallest elements. The function then removes the smallest elements from the heap k-1 times to reach the k-th smallest. Finally, it pops and returns the k-th smallest element from the heap. If the input list is valid, the function efficiently determines the desired element using a heap data structure.\n\n[end of description]\n"
    },
    "reverse_strings": {
        "code": "\n\ndef reverse_strings(input_list):\n    if (not input_list):\n        return []\n    reversed_list = []\n    for string in input_list:\n        reversed_list.append(string[::(- 1)])\n    return reversed_list\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of strings and returns a new list with each string reversed. The function should handle an empty list and should not modify the original list.",
        "description": "\n[description for function: reverse_strings]\nThis function takes a list of strings as input and returns a new list containing those strings reversed. If the input list is empty, it returns an empty list. It iterates through each string in the input list, reversing each one using slicing. The reversed strings are collected in a new list. Finally, the function returns the list of reversed strings. This allows for easy manipulation of string data by reversing their order.\n\n[end of description]\n"
    },
    "evaluate_expression": {
        "code": "\n\ndef evaluate_expression(expression):\n    result = 0\n    current_number = 0\n    current_operator = '+'\n    for char in expression:\n        if char.isdigit():\n            current_number = ((current_number * 10) + int(char))\n        else:\n            if (current_operator == '+'):\n                result += current_number\n            elif (current_operator == '-'):\n                result -= current_number\n            current_operator = char\n            current_number = 0\n    if (current_operator == '+'):\n        result += current_number\n    elif (current_operator == '-'):\n        result -= current_number\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string representing a mathematical expression consisting of non-negative integers, the minus sign (-), and the plus sign (+), and returns the result of the expression. The function should assume that the input is always a valid expression and that there are no spaces between numbers and operators.",
        "description": "\n[description for function: evaluate_expression]\nThis function evaluates a simple mathematical expression consisting of non-negative integers and the operators '+' and '-'. It iterates through each character in the expression, constructing numbers and applying the current operator to a cumulative result. When a non-digit character is encountered, it updates the result based on the last operator and resets the current number. After processing all characters, it ensures the last number is accounted for in the final result. The function returns the computed result as an integer. It handles expressions without parentheses or multiplication/division.\n\n[end of description]\n"
    },
    "dijkstra_shortest_path": {
        "code": "import heapq\n\ndef dijkstra_shortest_path(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if (current_distance > distances[current_node]):\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = (current_distance + weight)\n            if (distance < distances[neighbor]):\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    return {node: dist for (node, dist) in distances.items() if (dist < float('inf'))}\n",
        "dependencies": [],
        "task": "Write a Python function that takes a graph represented as a dictionary where keys are node labels and values are lists of tuples representing adjacent nodes and their respective distances, along with a start node label. The function should return a dictionary with the shortest distance from the start node to each other node in the graph using Dijkstra's algorithm. If a node is unreachable from the start node, it should not be included in the returned dictionary.",
        "description": "\n[description for function: dijkstra_shortest_path]\nThis function implements Dijkstra's algorithm to find the shortest path from a starting node to all other nodes in a weighted graph. It initializes distances to all nodes as infinity, except for the starting node, which is set to zero. A priority queue is used to explore the graph, processing nodes in order of their current known distance. For each node, it updates the distances to its neighbors if a shorter path is found. The function continues until all reachable nodes have been processed. Finally, it returns a dictionary of nodes with their corresponding shortest distances, excluding those that are unreachable.\n\n[end of description]\n"
    },
    "climb_stairs": {
        "code": "\n\ndef climb_stairs(n):\n    if ((n == 0) or (n == 1)):\n        return 1\n    ways = ([0] * (n + 1))\n    (ways[0], ways[1]) = (1, 1)\n    for i in range(2, (n + 1)):\n        ways[i] = (ways[(i - 1)] + ways[(i - 2)])\n    return ways[n]\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer `n` and returns the number of unique ways you can climb a staircase with `n` steps, given that you can take either 1 or 2 steps at a time. This is a variation of the Fibonacci sequence and can be solved using dynamic programming.",
        "description": "\n[description for function: climb_stairs]\nThis function calculates the number of distinct ways to climb a staircase with `n` steps, where each time you can either take one step or two steps. It initializes a list to store the number of ways to reach each step, starting with the base cases for 0 and 1 steps. Then, it iteratively fills in the list using the relation that the number of ways to reach step `i` is the sum of the ways to reach steps `i-1` and `i-2`. Finally, it returns the total number of ways to reach the `n`-th step. The approach efficiently uses dynamic programming to avoid redundant calculations. The function handles edge cases for 0 and 1 steps by returning 1 directly.\n\n[end of description]\n"
    },
    "bfs_adjacency_matrix": {
        "code": "from collections import deque\n\ndef bfs_adjacency_matrix(adj_matrix):\n    visited = set()\n    queue = deque([0])\n    visited.add(0)\n    visited_order = []\n    while queue:\n        current_node = queue.popleft()\n        visited_order.append(current_node)\n        for (neighbor, is_connected) in enumerate(adj_matrix[current_node]):\n            if (is_connected and (neighbor not in visited)):\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited_order\n",
        "dependencies": [],
        "task": "Write a Python function that takes a graph represented as an adjacency matrix and returns a list of nodes in the order they are visited using the Breadth-First Search (BFS) algorithm. The function should start the BFS from the first node (index 0).",
        "description": "\n[description for function: bfs_adjacency_matrix]\nThis function performs a breadth-first search (BFS) on a graph represented by an adjacency matrix, starting from the first node (index 0). It maintains a set of visited nodes to avoid processing the same node multiple times and uses a queue to explore neighboring nodes. As it traverses the graph, it records the order in which nodes are visited. The function iterates through the neighbors of the current node, adding unvisited and connected neighbors to the queue. Finally, it returns a list of nodes in the order they were visited. This approach effectively explores all reachable nodes from the starting point in a systematic manner.\n\n[end of description]\n"
    },
    "climb_stairs_v2": {
        "code": "\n\ndef climb_stairs_v2(n):\n    if ((n == 0) or (n == 1)):\n        return 1\n    dp = ([0] * (n + 1))\n    (dp[0], dp[1]) = (1, 1)\n    for i in range(2, (n + 1)):\n        dp[i] = (dp[(i - 1)] + dp[(i - 2)])\n    return dp[n]\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer `n` and returns the number of unique ways you can climb a staircase with `n` steps, given that you can take either 1 or 2 steps at a time. This is a classic dynamic programming problem that can be solved using memoization or bottom-up approach.",
        "description": "\n[description for function: climb_stairs]\nThis function calculates the number of distinct ways to climb a staircase with `n` steps, where each time you can either take one step or two steps. It initializes a list to store the number of ways to reach each step, starting with the base cases for 0 and 1 steps. Then, it iteratively fills in the list using the relation that the number of ways to reach step `i` is the sum of the ways to reach steps `i-1` and `i-2`. Finally, it returns the total number of ways to reach the `n`-th step. The approach uses dynamic programming to ensure efficient computation. The time complexity of the function is O(n).\n\n[end of description]\n"
    },
    "find_middle_node": {
        "code": "\n\ndef find_middle_node(head):\n    slow = head\n    fast = head\n    while (fast and fast.next):\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n",
        "dependencies": [],
        "task": "Write a Python function that takes the head node of a singly linked list and returns the middle node. If the list has an even number of nodes, return the second of the two middle nodes. The function should not use any extra space, and it should complete in a single pass through the list.",
        "description": "\n[description for function: find_middle_node]\nThis function takes the head of a linked list as input and aims to find the middle node of the list. It uses two pointers, one moving at a normal pace (slow) and the other moving at double the speed (fast). As the fast pointer traverses the list, it advances two nodes at a time while the slow pointer advances one node at a time. When the fast pointer reaches the end of the list, the slow pointer will be positioned at the middle node. The function then returns this middle node. This approach efficiently determines the middle node in a single pass through the list.\n\n[end of description]\n"
    },
    "symmetric_difference_v2": {
        "code": "\n\ndef symmetric_difference_v2(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    result = (set1 ^ set2)\n    return result\n",
        "dependencies": [],
        "task": "Write a Python function that takes two lists of integers and returns a set containing the symmetric difference of the two lists. The symmetric difference should contain elements that are in either of the lists but not in both. The order of elements in the returned set does not matter.",
        "description": "\n[description for function: symmetric_difference]\nThis function takes two lists as input and converts them into sets to eliminate any duplicate values. It then calculates the symmetric difference between the two sets, which includes elements that are in either of the sets but not in both. Finally, it returns the resulting set containing these unique elements. The use of sets ensures that the operation is efficient and straightforward. The output will be a set of items that are exclusive to each input list. Overall, it provides a clear way to identify differences between two collections of items.\n\n[end of description]\n"
    },
    "climbing_stairs": {
        "code": "\n\ndef climbing_stairs(n, memo=None):\n    if (memo is None):\n        memo = {}\n    if (n == 0):\n        return 1\n    if (n < 0):\n        return 0\n    if (n in memo):\n        return memo[n]\n    memo[n] = ((climbing_stairs((n - 1), memo) + climbing_stairs((n - 2), memo)) + climbing_stairs((n - 3), memo))\n    return memo[n]\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer `n` and returns the number of unique ways you can climb a staircase with `n` steps, given that you can take either 1, 2, or 3 steps at a time. Use memoization to optimize the recursive solution.",
        "description": "\n[description for function: climbing_stairs]\nThis function calculates the number of distinct ways to climb a staircase with `n` steps, where one can take 1, 2, or 3 steps at a time. It uses memoization to optimize the computation by storing previously calculated results for specific step counts. The base case returns 1 when there are zero steps to climb, indicating one way to stay at the ground level. If the number of steps is negative, it returns 0, as there are no valid ways to climb. The function recursively sums the ways to reach the current step by considering the last step taken as either 1, 2, or 3 steps back. Finally, it returns the total number of ways to climb the staircase for the given number of steps.\n\n[end of description]\n"
    },
    "find_most_frequent_element": {
        "code": "\n\ndef find_most_frequent_element(int_list):\n    if (not int_list):\n        return None\n    frequency = {}\n    for num in int_list:\n        frequency[num] = (frequency.get(num, 0) + 1)\n    max_count = 0\n    most_frequent = None\n    for (num, count) in frequency.items():\n        if ((count > max_count) or ((count == max_count) and ((most_frequent is None) or (num < most_frequent)))):\n            max_count = count\n            most_frequent = num\n    return most_frequent\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the element that appears the most frequently in the list. If there is a tie, return the smallest integer among the most frequent ones. If the list is empty, return None.",
        "description": "\n[description for function: find_most_frequent_element]\nThis function takes a list of integers as input and returns the most frequently occurring element in that list. If the list is empty, it returns None. It counts the occurrences of each integer using a dictionary to track their frequencies. After counting, it determines which integer has the highest frequency, and in case of a tie, it selects the smallest integer. Finally, it returns the most frequent integer found.\n\n[end of description]\n"
    },
    "depth_first_search_v2": {
        "code": "\n\ndef depth_first_search_v2(graph):\n    visited_order = []\n    visited = set()\n\n    def dfs_helper(node):\n        if (node not in visited):\n            visited.add(node)\n            visited_order.append(node)\n            for neighbor in graph[node]:\n                dfs_helper(neighbor)\n    for node in graph:\n        if (node not in visited):\n            dfs_helper(node)\n    return visited_order\n",
        "dependencies": [],
        "task": "Write a Python function that takes a graph represented as a dictionary where keys are node labels and values are lists of adjacent nodes, and returns a list of nodes in the order they are visited using the Depth-First Search (DFS) algorithm. The function should start the DFS from the first node provided in the dictionary.",
        "description": "\n[description for function: depth_first_search]\nThis function performs a depth-first search (DFS) on a given graph, represented as an adjacency list. It initializes a list to keep track of the order in which nodes are visited and a set to track visited nodes. The function iterates through each node in the graph, and if a node has not been visited, it calls a helper function to explore that node and its neighbors recursively. As nodes are visited, they are added to the visited list and marked as visited. Finally, the function returns the order of visited nodes after completing the search. This approach ensures that all nodes in the graph are explored systematically.\n\n[end of description]\n"
    },
    "is_valid_ipv6": {
        "code": "\n\ndef is_valid_ipv6(ip):\n    if (ip.count(':') != 7):\n        return False\n    groups = ip.split(':')\n    for group in groups:\n        if ((not (1 <= len(group) <= 4)) or (not all(((c in '0123456789abcdefABCDEF') for c in group)))):\n            return False\n    return True\n",
        "dependencies": [],
        "task": "Write a Python function that takes a string and returns True if the string is a valid IPv6 address, and False otherwise. A valid IPv6 address consists of eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (:). A string should only be considered a valid IPv6 address if it meets these criteria.",
        "description": "\n[description for function: is_valid_ipv6]\nThis function checks whether a given string is a valid IPv6 address. It first verifies that the address contains exactly seven colons, indicating the correct number of groups. Then, it splits the address into its constituent groups and checks each group for length and valid hexadecimal characters. Each group must be between 1 and 4 characters long and can only contain digits or letters from 'a' to 'f' (case insensitive). If any group fails these checks, the function returns False; otherwise, it returns True, indicating a valid IPv6 address.\n\n[end of description]\n"
    },
    "prime_factors": {
        "code": "\n\ndef prime_factors(n):\n    factors = []\n    while ((n % 2) == 0):\n        factors.append(2)\n        n //= 2\n    for i in range(3, (int((n ** 0.5)) + 1), 2):\n        while ((n % i) == 0):\n            factors.append(i)\n            n //= i\n    if (n > 2):\n        factors.append(n)\n    return factors\n",
        "dependencies": [],
        "task": "Write a Python function that takes an integer n and returns a list of its prime factors. The list should contain the prime factors in ascending order and can include duplicates if the prime factor appears multiple times in the factorization.",
        "description": "\n[description for function: prime_factors]\nThis function calculates the prime factors of a given integer. It starts by checking for the factor 2 and divides the number by 2 until it can no longer do so. Then, it iterates through odd numbers starting from 3 up to the square root of the number, checking for divisibility and collecting factors. If the remaining number is greater than 2 after the loop, it is also added to the list of factors. Finally, the function returns a list of all prime factors found.\n\n[end of description]\n"
    },
    "min_coins_for_change": {
        "code": "\n\ndef min_coins_for_change(denominations, target):\n    dp = ([float('inf')] * (target + 1))\n    dp[0] = 0\n    for coin in denominations:\n        for amount in range(coin, (target + 1)):\n            dp[amount] = min(dp[amount], (dp[(amount - coin)] + 1))\n    return (dp[target] if (dp[target] != float('inf')) else (- 1))\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of non-negative integers representing coin denominations and a target amount. The function should return the minimum number of coins needed to make up that amount. If it is not possible to make up the amount, return -1. Assume you have an infinite number of each type of coin.",
        "description": "\n[description for function: min_coins_for_change]\nThis function calculates the minimum number of coins needed to make a specified target amount using given denominations. It initializes a dynamic programming array to store the minimum coins required for each amount up to the target. For each coin denomination, it updates the array by checking if using the coin results in fewer coins for each possible amount. If the target amount can be formed, it returns the minimum number of coins; otherwise, it returns -1 to indicate that the target cannot be achieved with the given denominations. The approach efficiently determines the solution using a bottom-up dynamic programming technique.\n\n[end of description]\n"
    },
    "find_kth_smallest_v2": {
        "code": "import heapq\n\ndef find_kth_smallest_v2(nums, k):\n    if (k > len(nums)):\n        return None\n    min_heap = []\n    for num in nums:\n        heapq.heappush(min_heap, num)\n    for _ in range((k - 1)):\n        heapq.heappop(min_heap)\n    return heapq.heappop(min_heap)\n",
        "dependencies": [],
        "task": "Write a Python function that takes a list of integers and returns the kth smallest element in the list using a min-heap. If k is larger than the number of elements in the list, return None.",
        "description": "\n[description for function: find_kth_smallest]\nThis function takes a list of numbers and an integer k as input, aiming to find the k-th smallest element in the list. It first checks if k is greater than the length of the list, returning None if true. A min-heap is created to store the numbers, allowing for efficient retrieval of the smallest elements. The function then removes the smallest elements from the heap k-1 times to reach the k-th smallest. Finally, it pops and returns the k-th smallest element from the heap. If the input list is valid, the function efficiently determines the desired element using a heap data structure.\n\n[end of description]\n"
    }
}